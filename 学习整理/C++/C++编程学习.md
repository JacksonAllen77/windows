# C++编程

<aside>
🧑‍💻 C++总览

- 基础操作——[C++基本框架](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[cout](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[注释](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[变量](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)&[常量](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[cin数据输入](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- 数据类型——[整形(int)](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[浮点型&保留小数点位数（float、double）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[字符型(str)](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[字符串型(string)](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[布尔型(bool)](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[sizeof统计内存大小](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[转义符(换行、水平制表符等)](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- 数学运算——[算术运算符（加减乘除](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[取余%](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[递增递减++）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[赋值运算符（=、+=）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[比较运算符（==、！=、>、<、>=、<=）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[逻辑运算符（&&、||、！）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- 流程结构
    - 选择结构——[单条件语句（if）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[多条件语句(if   else if   else)](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[多条件嵌套(if套if)](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[选择案例（三只小猪称体重）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[三目运算符（比较？是果：否果）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[switch](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 循环结构——[while](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[while案例（猜数字）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[do…while](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[do while案例（水仙花数）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[for循环](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[for案例（猜数字）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[for循环嵌套](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[for循环嵌套案例（乘法口诀表）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 跳转结构——[break](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[continue](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[go to无条件跳转](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- 数组——[1维数组定义方式](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[1维数组内存大小&首地址](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[数组案例（五只小猪称体重）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[数组元素逆置](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[数组案例（冒泡排序）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[2维数组定义方式](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[2维数组内存大小&行列数&首地址](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[2维数组案例（成绩统计）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- 函数——[定义函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数调用](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[值传递&实参形参](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数常见样式（无参无返、有参无返、无参有返、有参有返）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数声明](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数分文件编写](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- 指针——[指针的定义&引用](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[指针所占内存空间](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[空指针](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)&[野指针](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[修饰指针](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[指针数组联用（利用指针访问数组元素）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[指针函数联用（利用地址传递改变实参）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[指针数组函数联用案例（冒泡排序）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)      【&a表示取a的地址、*p表示取p指针的内容】
- 结构体——[定义结构体](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体数组](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体指针](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体嵌套](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体中const应用](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体案例（毕业设计）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体案例（英雄冒泡排序）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++基础综合案例——通讯录管理系统【[设置显示菜单](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[退出通讯录功能](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[添加联系人功能](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[显示联系人功能](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[删除联系人功能](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[查找联系人功能](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[修改联系人功能](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[清空联系人](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)】
- C++内存区域——[代码区](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[全局区](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[栈区](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[堆区&new操作符](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++引用——[引用语法](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[引用注意事项](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[引用传递](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[引用作为函数返回值](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[引用本质（指针常量）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[常量引用](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++函数高级——[函数默认参数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数占位参数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数重载](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数重载注意事项](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++类&对象
    - 封装——[创建类&赋值](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[创建类&赋值案例（设计学生类）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类访问权限](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[结构体与类区别](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[私有权限控制读写](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[私有权限控制读写案例（立方体）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 对象特性——[构造函数&析构函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[构造函数2种分类&3种调用](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[拷贝构造函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[构造函数调用原则](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[深拷贝&浅拷贝](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[初始化列表](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类对象作为类成员](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[静态成员变量](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[静态成员函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[成员变量&成员函数分开储存](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[this指针](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[空指针访问成员函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[const修饰长函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[const修饰常对象](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 友元——[全局函数作友元](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类作友元](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[成员函数作友元](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 运算符重载——[加号运算符重载](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[左移运算符重载](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[递增运算符重载](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[赋值运算符重载](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[关系运算符重载](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数调用运算符重载&仿函数&匿名函数对象](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 继承——[继承语法](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[继承方式](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[继承中对象模型](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[构造和析构的顺序](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[同名成员属性&同名成员函数处理](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[同名静态成员变量&同名静态成员函数处理](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、   [多继承语法](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[菱形继承问题&解决方法](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 多态——[多态语法](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[多态原理剖析](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[多态案例（设计计算器）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[纯虚函数和抽象类](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[纯虚函数和抽象案例（制作饮品）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[虚析构和纯虚析构](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[虚析构和纯虚析构案例（电脑组装）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++读写文件——[文本文件写文件](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[文本文件读文件](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[二进制文件写文件](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[二进制文件读文件](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++模板——[函数模板语法](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数模板注意事项](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[函数模板案例（数组排序）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[普通函数&函数模板区别](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[普通函数与函数模板调用](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[模板的局限性](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板基本语法](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板&函数模板区别](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板成员函数创建时机](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板对象作函数参数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板与继承](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板成员函数类外实现](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板份文件编写](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[类模板与友元](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++的数据容器
    - string容器（字符串）——[string构造函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[string赋值操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[string字符串拼接](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[string字符串查找和替换](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[string字符串比较](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[string字符存取](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[string字符串插入和删除](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[string字串获取](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - vector容器（单端数组）——[vector存放内置数据类型](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector存放自定义数据类型](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector嵌套vector](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector构造函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector赋值操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector容器和大小](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector插入和删除](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector数据存取](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector互换容器](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector预留空间](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[vector排序操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - deque容器（双端数组）——[deque构造函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[deque赋值操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[deque大小操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[deque插入和删除](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[deque数据存取](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[deque排序操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[STL案例（评委打分）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - stack容器（先进后出）——[stack基本概念](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[stack常用接口](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - queue容器（先进先出）——[queue基本概念](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[queue常用接口](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - list容器（非连续线性、双向迭代器）——[list基本概念](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[list构造函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[list赋值和交换](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[list大小操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[list插入和删除](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[list数据存取](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[list反转和排序](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[list案例（列表排序）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - set容器（自动排序）——[set构造函数&赋值操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set大小和交换](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set插入和删除](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set查找和统计](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set&multiset区别](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set内置数据类型排序](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set自定义数据类型排序](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - map容器（键值对，按键自动排序）——[pair对组的创建](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[map构造函数&赋值操作](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[map大小和交换](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[map插入和删除](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[map查找和统计](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[map内置类型排序](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[map自定义类型排序](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[STL案例（员工分组）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++函数对象——[函数对象（仿函数）基本使用](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[一元谓词](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[二元谓词](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[内建算术仿函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[内建关系仿函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[内建逻辑仿函数](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
- C++算法
    - 常用遍历方法——[for_each（遍历容器）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[transform（搬运到另一个容器）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 常用查找算法——[find（查找元素）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[find_if（按条件查找）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[adjacent_find（查找相邻重复元素）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[binary_search（二分查找法）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[count（统计元素个数）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[count_if（按条件统计元素个数）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 常用排序算法——[sort（对容器元素进行排序）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[random_shuffle（指定范围内元素随机调整次序）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[merge（两个容器元素合并，并储存在另一个容器中）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[reverse（将容器内容元素进行反转）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 常用拷贝和替换算法——[copy（指定范围内的元素拷贝到另一容器中）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[replace（将指定范围内的旧元素改为新元素）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[replace_if（将指定范围内的旧元素替换新元素）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[swap（互换两个容器的元素）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 常用算术生成算法——[accumulate（计算容器中元素累计总和）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[fill（向容器中添加元素）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    - 常用集合算法——[set_intersection（求两个容器的交集）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set_union（求两个容器的并集）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)、[set_difference（求两个容器的差集）](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
</aside>

- cout代码[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——C++基本架构
    
    </aside>
    
    ```cpp
     #include<iostream>
    using namespace std;
    
    int main()
    {
    
    	system("pause");
    
    		return 0;
    }
    ```
    
    ```cpp
     #include<iostream>
    using namespace std;
    
    int main()//返回值类型【int】 入口函数【main】 （函数列表）
    {
    
    	system("pause");//实现按任意键继续
    
    		return 0;//返回正常退出值
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled.png)
    
    ---
    
    <aside>
    🏆 代码应用——cout打印代码
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	cout << "Hello World" << endl; //输出Hello World
    	
    	system("pause");
    
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%201.png)
    
    - 注意——不同cpp文件的main函数命名要不同
    
    ---
    
- C++注释【单行注释、多行注释】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——单行注释&多行注释
    
    </aside>
    
    ```cpp
    //这是单行注释
    
    /*这是多行注释
    这是多行注释
    这是多行注释*/
    ```
    
    - 单行注释——//XXXX
    - 多行注释——/*XXXX*/【快捷键：选中注释内容ctrl+k+c】
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%202.png)
    
    ---
    
- C++变量&常量&关键字&命名规则【变量赋值、定义常量、关键字】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——C++变量
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 25; //定义a中变量内容为25
    	cout << "a=" << a << endl; //输出a=变量内容结果
    
    	system("pause");
    	
    	return 0;
    }
    
    /*定义a变量中内容为25
    输出a=25*/
    ```
    
    - 变量定义语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%203.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%204.png)
    
    ---
    
    <aside>
    🏆 代码应用——C++常量
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #define Day 7 
    	//定义宏常量Day为7
    
    int main()
    {
    	cout << "一周共有" << Day << "天" << endl; //输出一周共有Day（宏常量中的内容）天
    
    	system("pause");
    
    	return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	const int month = 12; //定义month常量为12
    	cout << "一年共有:" << month << "月份" << endl; //输出一年共有:month（常量中的内容）月份
    
    	system("pause");
    
    	return 0;
    }
    ```
    
    - 常量定义语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%205.png)
        
    - #define——宏常量定在main的上方
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%206.png)
        
    - const XXX——定义常量在main的内部
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%207.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——关键字
    
    </aside>
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%208.png)
    
    - 变量和常量不能定义关键字——第二个int是关键字，不能作为变量的名称
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%209.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——标识符【常量、变量】命名规则
    
    </aside>
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2010.png)
    
    - 报错情况
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2011.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2012.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2013.png)
    
    ---
    
- C++数据输入【cin】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——数据输入
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 0;
    	cout << "请给整型变量a赋值：" << endl;//请求输入的基本结构
    	cin >> a;
    	cout << "整型变量a=" << a<<endl;
    	
    	float b1 = 3.14;
    	cout << "请给浮点型变量b1赋值：" << endl;
    	cin >> b1;
    	cout << "浮点型变量b1=" << b1 << endl;
    	
    	char c1 = 'c';
    	cout << "请给字符型变量c1赋值：" << endl;
    	cin >> c1;
    	cout << "字符型变量c1=" << c1 << endl;
    	
    	char d1[] = "我爱你";
    	cout << "请给字符串型变量d1赋值：" << endl;
    	cin >> d1;
    	cout << "字符串型变量d1=" << d1 << endl;、
    	
    	bool e1 = false;
    	cout << "请给布尔型变量e1赋值：" << endl;
    	cin >> e1;
    	cout << "布尔型变量e1=" << e1 << endl;
    	
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 输入
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2014.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2015.png)
        
    
    ---
    
- C++数据类型【整形、浮点型、字符型、字符串型、布尔型、sizeof、转义符】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——整形
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    short num1 = 10; //四个指令的范围都是有限的，short短整形范围（-32768~32767）
    int num2 = 100;
    long num3 = 1000;
    long long num4 = 10000;
    
    cout << "num1:" << num1 << endl; //输出num1变量中内容
    cout << "num2:" << num2 << endl;
    cout << "num3:" << num3 << endl;
    cout << "num4:" << num4 << endl;
    
    system("pause");
    
    return 0;
    }
    ```
    
    - 整形
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2016.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2017.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——统计内存大小sizeof
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	short num1 = 10; //定义num1变量内容为10
    	int num2 = 100; 
    	long num3 = 1000;
    	long long num4 = 10000;
    
    	cout << "short占用的内存空间为：" << sizeof(num1)<<endl; //输出short的所占内存大小
    	cout << "int占用的内存空间为：" << sizeof(int) << endl; //输出int的所占内存大小
    	cout << "long占用的内存空间为：" << sizeof(num3) << endl; //输出long的所占内存大小
    	cout << "long long占用的内存空间为：" << sizeof(long long) << endl;//输出long long的所占内存大小
    
    	system("pause");
    
    	return 0;
    }
    ```
    
    - sizeof语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2018.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2019.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——浮点型
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	float a1 = 3.14f; //定义单精度变量a1内容为3.14【f为单精度标记】
    	cout << "a1中的内容为：" << a1 << endl; //输出a1变量中内容
    	double a2 = 3.1415926; //定义双精度变量a2内容为3.1415926
    	cout << "a2中的内容为：" << a2 << endl; //输出a2变量中内容
    	cout << "a1所占内存大小为：" << sizeof(a1) << endl; //输出float的所占内存大小
    	cout << "a2所占内存大小为：" << sizeof(a2) << endl; //输出double的所占内存大小
    	
    	//科学计数法
    	float b1 = 3e2; //定义单精度变量b1内容为300
    	cout << "b1中的内容为：" << b1 << endl; //输出b1变量中内容
    	float b2 = 3e-2; //定义单精度变量b2内容为0.03
    	cout << "b2中的内容为：" << b2 << endl; //输出b2变量中内容
    
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    - 浮点型
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2020.png)
    
    例如3.14——由3、1、4共3个有效数字
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2021.png)
    
    ---
    
    <aside>
    🏆 代码应用——字符型&ASCII码
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	char dj = 'a'; //定义dj字符变量内容为a
    	cout << "dj的内容为：" << dj << endl; //输出dj的内容
    	cout << "char所占内存大小为：" << sizeof(char) << endl; //输出char所占内存大小
    	//char dj2 = "b"; [此例是错误的！！]创建字符型变量的时候，要用单引号
    	//char dj2='abcdefg' [此例是错误的！！]创建字符型变量的时候，单引号内只能用一个字符
    	cout << (int)dj << endl; //字符型变量对应的ASCII编码
    	//常用ASCII码记忆 a-97,推算bcd.....
    	//常用ASCII码记忆 A-65
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    - 字符型
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2022.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2023.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2024.png)
        
        - ASCII
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2025.png)
            
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2026.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——字符串类型
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    //用string字符风格时，要包含这个头文件
    
    int main()
    {
    	char str[] = "hello world"; //注意变量名后加[]，否则为单个字符；等号后面要用双引号
    	cout << str << endl;
    	string str2 = "你好世界";//要包含includ<string>的头文件
    	cout << str2 << endl;
    	
    	system("pause");
    
    	return 0;
    }
    ```
    
    - 字符串
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2027.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2028.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2029.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——布尔型
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	bool flag = true; //创建bool类型变量flag为true
    	cout << "flag内容为：" << flag<<endl;//输出flag中内容
    	
    	flag = false;//重新定义变量falg为false
    	cout << "flag内容为：" << flag << endl;//再次输出flag中内容
    	cout << "bool所占内存大小为：" << sizeof(bool) << endl;//输出bool类型所占内存大小
    
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    - 布尔型
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2030.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2031.png)
        
    
    ---
    
    ---
    
    <aside>
    🏆 代码应用——转义字符
    
    </aside>
    
    ```cpp
    //    \a 警报 ASCII码007        //转义字符需要被""包含在内
    //    \b 退格 ASCII码008
    //    \f 换页 ASCII码012
    //    \n 换行 ASCII码010
    //    \r 回车 ASCII码013
    //    \t 水平制表 ASCII码009
    //    \v 垂直制表 ASCII码011
    //    \\ 反斜杠字符 ASCII码092
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	cout << "hello world\n你好\n"; //输出hello world换行输出你好换行
    	cout << "\\" << endl;//输出\
    	cout << "aaaa\thello world" << endl;//输出aaaa在制表位8位后输出hello world
    	cout << "aa\thello world" << endl;//输出aa在制表位8位后输出hello world
    	cout << "aaaaaa\thello world" << endl;//输出aaaaaa在制表位8位后输出hello world
    
    	system("pause");
    
    	return 0;
    	}
    ```
    
    - 转义字符
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2032.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2033.png)
        
    
- C++数学运算【四则运算符、赋值运算符、比较运算符、逻辑运算符】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2034.png)
    
    <aside>
    🏆 代码应用——算术运算符【加减乘除】整数、小数都进行运算
    
    </aside>
    
    ```cpp
    	#include<iostream>
    	using namespace std;
    	
    	int main()
    	{
    		int a1 = 10;
    		int b1 = 3;
    		cout<< a1+b1<<endl;
    		cout<< b1-a1<<endl;
    		cout<< a1*b1<<endl;
    		cout << a1 / b1 << endl; //两个整数相除，结果为整数，将小数去除【两数相除，除数不能为0】
    		
    		system("pause");
    	
    		return 0;
    	
    	}
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	double d1 = 0.5;
    	double d2 = 0.25;
    	cout<< a1+b1<<endl;
    	cout<< b1-a1<<endl;
    	cout<< a1*b1<<endl;
    	cout << a1 / b1 << endl; //两个整数相除，结果为整数，将小数去除【两数相除，除数不能为0】
    	
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 算术运算符——加减乘除【+-*/】
        - 除数不能为0
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2035.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2036.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——算术运算符【取余】仅整数可进行运算
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a1 = 10; //定义变量a1变量为10
    	int b1 = 3; //定义变量b1变量为3
    	cout << a1%b1 << endl;//两个整数相处，除数不能为0，故无法实现取余运算；两个小数不能做取余运算
    	
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 算术运算符——加减乘除【%】
        - 除数不能为0
        - 两个小数不能做取余运算
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2037.png)
    
    ---
    
    <aside>
    🏆 代码应用——算术运算符【递增递减】
    
    </aside>
    
    ```cpp
    //前置递增、后置递增
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10; //定义变量a变量为10
    	int b1 = ++a * 10;//定义变量b为运算结果【前置递增为先变量a进行+1,后进行运算】
    	cout << "a=" << a << endl;//输出a变量的运算结果
    	cout << "b1=" << b1 << endl;//输出b1变量的运算结果
    	
    	int c = 10;//定义变量c变量为10
    	int b2 = c++ * 10;//定义变量b2为运算结果【后置递增为先进行运算,后变量c进行+1】
    	cout << "c=" << c << endl;//输出c变量的运算结果
    	cout << "b2=" << b2 << endl;//输出b2变量的运算结果
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ```cpp
    //前置递减、后置递减
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10; //定义变量a变量为10
    	int b1 = --a * 10;//定义变量b为运算结果【前置递增为先变量a进行-1,后进行运算】
    	cout << "a=" << a << endl;//输出a变量的运算结果
    	cout << "b1=" << b1 << endl;//输出b1变量的运算结果
    	
    	int c = 10;//定义变量c变量为10
    	int b2 = c-- * 10;//定义变量b2为运算结果【后置递增为先进行运算,后变量c进行-1】
    	cout << "c=" << c << endl;//输出c变量的运算结果
    	cout << "b2=" << b2 << endl;//输出b2变量的运算结果
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 算术运算符——递增递减
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2038.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2039.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2040.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——赋值运算符
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10; //定义变量a变量为10
    	a = 100;//重新赋值变量a为100
    	cout << "a=" << a << endl;//输出a变量的结果
    
    	a = 10;//重新赋值变量a为10
    	a += 2;//加等于
    	cout << "a=" << a << endl;//输出a变量的结果
    
    	a = 90;//重新赋值变量a为90
    	a -= 2;//减等于
    	cout << "a=" << a << endl;//输出a变量的结果
    
    	a = 3;//重新赋值变量a为3
    	a *= 2;//乘等于
    	cout << "a=" << a << endl;//输出a变量的结果
    
    	a = 6;//重新赋值变量a为6
    	a /= 3;//除等于
    	cout << "a=" << a << endl;//输出a变量的结果
    
    	a = 10;//重新赋值变量a为10
    	a %= 3;//模等于;
    	cout << "a=" << a << endl;//输出a变量的结果
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 赋值运算符
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2041.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2042.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——比较运算符
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10; //定义变量a变量为10
    	int b = 100;//定义变量b变量为100
    	cout << "a是否等于b的结果：" << (a ==b) << endl;//输出a与b相等比较结果
    	cout << "a是否不等于b的结果：" << (a != b) << endl;//输出a与b不相等比较结果
    	cout << "a是否大于b的结果：" << (a > b) << endl;//输出a与b大于比较结果
    	cout << "a是否小于b的结果：" << (a < b) << endl;//输出a与b小于比较结果
    	cout << "a是否大于等于b的结果：" << (a >= b) << endl;//输出a与b大于等于比较结果
    	cout << "a是否小于等于b的结果：" << (a <= b) << endl;//输出a与b小于等于比较结果
    	
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 比较运算符
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2043.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2044.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2045.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——逻辑运算符
    
    </aside>
    
    ```cpp
    //逻辑非【取反操作】
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10; //定义变量a变量为10【除了0均为真】
    	cout << "！a的结果为:" << !a << endl;//输出a取反后结果，即假
    	cout << "！！a的结果为:" << !!a << endl;//输出a两次取反后结果，即真
    	
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ```cpp
    //逻辑与【同真为真，其余为假】
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10; //定义变量a变量为10【除了0均为真】
    	int b = 2;//定义变量b变量为2【除了0均为真】
    	int c = 0;//定义变量c变量为0，为假
    	int d = 0;//定义变量d变量为0，为假
    	cout << "a与b逻辑与的结果为:" << (a && b) << endl;//输出a与b逻辑与结果【同真为真，其余为假】
    	cout << "a与c逻辑与的结果为:" << (a && c) << endl;//输出a与c逻辑与结果【同真为真，其余为假】
    	cout << "c与d逻辑与的结果为:" << (c && d) << endl;//输出c与d逻辑与结果【同真为真，其余为假】
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ```cpp
    //逻辑或【同假为假，其余为真】
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10; //定义变量a变量为10【除了0均为真】
    	int b = 2;//定义变量b变量为2【除了0均为真】
    	int c = 0;//定义变量c变量为0，为假
    	int d = 0;//定义变量d变量为0，为假
    	cout << "a与b逻辑或的结果为:" << (a || b) << endl;//输出a与b逻辑或结果【同假为假，其余为真】
    	cout << "a与c逻辑或的结果为:" << (a || c) << endl;//输出a与c逻辑或结果【同假为假，其余为真】
    	cout << "c与d逻辑或的结果为:" << (c || d) << endl;//输出c与d逻辑或结果【同假为假，其余为真】
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 逻辑运算符
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2046.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2047.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2048.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2049.png)
        
    
    ---
    
- C++程序流程结构——选择结构【单条件语句、多条件语句、多条件嵌套、三目运算符、switch】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2050.png)
    
    <aside>
    🏆 代码应用——单条件语句
    
    </aside>
    
    ```cpp
    //单行if语句【用户输入分数,先打印用户分数；如果大于等于600分，恭喜他；如果小于600分，退出】
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int user_score = 0;//定义用户分数为0
    	cout << "请输入您的分数" << endl;
    	cin >> user_score;//请求用户输入分数
    	cout << "您的分数为：" << user_score << endl;//打印用户分数
    	
    	//选择结构，若满足条件，输出结果1；不满足条件，则返回
    	if (user_score >= 600)//注意事项！！！【if条件后不要加分号】
    	{
    		cout << "恭喜您考上了一本大学" << endl;
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ```cpp
    //多行if语句【用户输入分数,先打印用户分数；如果大于等于600分，恭喜他；如果小于600分，鼓励他】
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int user_score = 0;//定义用户分数为0
    	cout << "请输入您的分数" << endl;
    	cin >> user_score;//请求用户输入分数
    	cout << "您的分数为：" << user_score << endl;//打印用户分数
    
    	if (user_score >= 600)//选择结构，满足条件，输出结果1
    	{
    		cout << "恭喜您考上了一本大学" << endl;
    	}
    	else//若不满足条件，输出结果2
    	{
    		cout << "希望你未来再接再厉" << endl;
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 单行条件语句【如果为真，输出结果1；为假，则退出】
        - if条件后不要加分号，否则是否满足条件，均输出
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2051.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2052.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2053.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2054.png)
        
    - 多行条件语句【如果为真，输出结果1；为假，则退出】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2055.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2056.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2057.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——多条件语句
    
    </aside>
    
    ```cpp
    //多条件语句
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int user_score = 0;//定义用户分数为0
    	cout << "请输入您的分数" << endl;
    	cin >> user_score;//请求用户输入分数
    	cout << "您的分数为：" << user_score << endl;//打印用户分数
    	
    	//选择结构，若分数大于650，则考入985大学
    	// 若分数大于550，则考入211大学
    	// 若分数大于500，则考入一本大学
    	// 以上均不满足，鼓励他再接再厉
    	if (user_score >= 650)//如果分数满足条件1，输出结果1
    	{
    		cout << "恭喜您，考上了985高校" << endl;
    	}
    	else if (user_score >= 550)//如果分数满足条件2，输出结果2
    	{
    		cout << "恭喜您，考上了211高校" << endl;
    	}
    	else if ( user_score >= 500)//如果分数满足条件3，输出结果3
    	{
    		cout << "恭喜您，考上了一本高校" << endl;
    	}
    	else//以上条件均不满足，输出结果4
    	{
    		cout << "希望你再接再厉" << endl;
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 多条件语句
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2058.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2059.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2060.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2061.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2062.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——多条件嵌套
    
    </aside>
    
    ```cpp
    //多条件嵌套语句
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int user_score = 0;//定义用户分数为0
    	cout << "请输入您的分数" << endl;
    	cin >> user_score;//请求用户输入分数
    	cout << "您的分数为：" << user_score << endl;//打印用户分数
    	
    	//选择结构，若分数大于等于650，则考入985大学；
    		//	其中大于等于685，考入北大
    		//	其中大于等于670，考入清华
    		//	其余条件，考入人大
    	// 若分数大于等于550，则考入211大学
    	// 若分数大于等于500，则考入一本大学
    	// 以上均不满足，鼓励他再接再厉
    	if (user_score >= 650)//如果分数满足条件1，输出结果1;再进入二层条件判断
    	{
    		cout << "恭喜您，考上了985高校" << endl;
    		if (user_score >= 685)
    		{
    			cout << "恭喜您，考上了北京大学" << endl;//满足二层条件2，输出新结果1
    		}
    		else if (user_score >= 670)
    		{
    			cout << "恭喜你，考上清华大学" << endl;//满足二层条件3，输出新结果2
    		}
    		else
    		{
    			cout << "恭喜你，考上人民大学" << endl;//其余二层条件，输出新结果3
    		}
    	}
    	else if (user_score >= 550)//如果分数满足条件2，输出结果2
    	{
    		cout << "恭喜您，考上了211高校" << endl;
    	}
    	else if ( user_score >= 500)//如果分数满足条件3，输出结果3
    	{
    		cout << "恭喜您，考上了一本高校" << endl;
    	}
    	else//以上条件均不满足，输出结果4
    	{
    		cout << "希望你再接再厉" << endl;
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2063.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2064.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2060.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2065.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2061.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2062.png)
    
    ---
    
    <aside>
    🏆 代码应用——选择结构案例【三只小猪称体重】
    
    </aside>
    
    ```cpp
    //三只小猪称体重，判断哪只最重
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int pig_a_weight = 0;//创建三只小猪体重变量
    	int pig_b_weight = 0;
    	int pig_c_weight = 0;
    
    	cout << "请输入小猪a的体重" << endl;//请求输入三只小猪的体重参数
    	cin >> pig_a_weight;
    	cout << "请输入小猪b的体重" << endl;
    	cin >> pig_b_weight;
    	cout << "请输入小猪c的体重" << endl;
    	cin >> pig_c_weight;
    
    	cout << "小猪a的体重为" << pig_a_weight << endl;//显示三只小猪的体重参数
    	cout << "小猪b的体重为" << pig_b_weight << endl;
    	cout << "小猪c的体重为" << pig_c_weight << endl;
    
    	if (pig_a_weight>pig_b_weight)
    	{
    		if (pig_a_weight > pig_c_weight)
    		{
    			cout << "小猪a最重" << endl;
    		}
    		else
    		{
    			cout << "小猪c最重" << endl;
    		}
    	}
    	else
    	{
    		if (pig_b_weight > pig_c_weight)
    		{
    			cout << "小猪b最重" << endl;
    		}
    		else
    		{
    			cout << "小猪c最重" << endl;
    		}
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2066.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2067.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2068.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2069.png)
    
    ---
    
    <aside>
    🏆 代码应用——三目运算符
    
    </aside>
    
    ```cpp
    //三目运算符【如果满足条件，输出1，否则输出2】
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10;
    	int b = 20;
    	int c = 0;
    
    	c = a > b ? a: b;//如果a大于b，输出a；否则输出b[表达式？是结果：否结果]
    	cout << "c=" << c << endl;
    
    	//C++三目运算符返回的是变量，可以继续赋值
    	(a > b ? a : b) = 100;//将输出变量定义为100
    
    	cout << "a=" << a << endl;//输出此时变量a的值
    	cout << "b=" << b << endl;//输出此时变量b的值
    	cout << "c=" << c << endl;//输出此时变量c的值
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - 三目运算符
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2070.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2071.png)
    
    ---
    
    <aside>
    🏆 代码应用——switch语句
    
    </aside>
    
    ```cpp
    //switch语句【给电影打分】
    	//如果分数在9-10，则输出1
    	//如果分数在7-8，则输出2
    	//如果分数在4-6，则输出3
    	//如果以上均不是，则输出4
    
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int movie_score = 0;//定义电影分数变量
    
    	cout << "请输入您对该部电影的评分" << endl;//请求用户输入电影分数
    	cin >> movie_score;
    
    	switch(movie_score)//根据不同分数，输出不同结果
    	{
    		case 10://注意是冒号不是分号
    		case 9://注意是冒号不是分号
    			cout << "这部电影是经典" << endl;
    			break;//这行不能删除，以上结果在此中断
    
    		case 8:
    		case 7:
    			cout << "这部电影非常好" << endl;
    			break;
    
    		case 6:
    		case 5://这行不能删除，否则5分也为烂片
    		case 4:
    			cout << "这部电影一般" << endl;
    			break;
    		default://注意是冒号不是分号
    			cout << "这部电影是烂片" << endl;
    			break;
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2072.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2073.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2074.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2075.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2076.png)
    
    ---
    
    <aside>
    🏆 代码应用——if语句、三目运算符、switch语句
    
    </aside>
    
    ```cpp
    //if 语句——优点：判断范围可以是个区间；缺点：编辑比较复杂，执行效率低
    
    //三目运算符——只能涉及是两个变量，不能直接进行三变量比较关系
    
    //switch语句——优点：编辑机构清晰，执行效率高；缺点：判断只能是整型或字符型，不可以是个区间
    
    ```
    
    ---
    
- C++程序流程结构——循环结构【while、do…while、for循环、for循环嵌套】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——while循环语句【先循环，再执行】
    
    </aside>
    
    ```cpp
    //while语句【先定义变量，进入循环结构；先输出变量值，再+1；当变量值满足while条件时，退出循环】
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int number = 0;//定义变量
    	
    	while (number < 10)//进行循环结构，括号内为退出循环条件【注意事项：避免死循环出现】
    	{
    		cout << number << endl;//输出变量number中的参数
    		number++;//变量number参数+1
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - while循环语句
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2077.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2078.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——while实际案例【猜数字】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<ctime>//利用时间生成随机数时，所需要包含的头文件
    
    int main()
    {
    	srand((unsigned int)time(NULL));//添加随机数种子，利用系统时间生成随机数，防止每次随机数都一样【需要ctime头文件】
    	int num = rand() % 100 + 1;//在0~100中生成随机数
    
    	int user_num = 0;//定义用户猜测数变量
    	
    	while (user_num=num)//建立循环结构，如果猜对了，退出循环结构
    	{
    		cin >> user_num;//请求用户输入
    		if (user_num > num)//如果满足条件1，输出结果1
    		{
    			cout << "你猜大了" << endl;
    		}
    		else if (user_num < num)//如果满足条件2，输出结果2
    		{
    			cout << "你猜小了" << endl;
    		}
    		else//否则，输出结果3，退出
    		{	
    			cout << "恭喜你猜了" << endl;
    			break;//退出猜测循环
    		}
    	}
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2079.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2080.png)
    
    ---
    
    ---
    
    <aside>
    🏆 代码应用——do…while语句【先执行，再循环】
    
    </aside>
    
    ```cpp
    //do..while语句
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int number = 0;//定义变量number
    
    	do //循环执行代码，判断是否满足条件；不满足再do循环语句
    	{
    		cout << number << endl;//输出变量number中的参数
    		number++;//变量number参数+1
    	} 
    	while (number < 10);//满足要求结束
    	
    	system("pause");
    
    	return 0;
    
    }
    
    //while 先判断条件，再执行循环语句
    //do while 先执行一次循环语句，再判断条件
    ```
    
    - do…while语句
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2081.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2082.png)
        
    
    <aside>
    🏆 代码应用——do..while实际案例【水仙花数】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int number = 100;//定义数字变量
    	do
    	{
    		int a = 0;//定义个位变量
    		int b = 0;//定义十位变量
    		int c = 0;//定义百位变量
    		
    		a = number % 10;//获取数字的个位
    		b = number / 10 % 10;//获取数字的十位
    		c = number / 100;//获取数字的百位
    
    		if(a*a*a+b*b*b+c*c*c == number)//如果是水仙花数，才打印
    		{
    			cout << number << endl;
    		}
    		
    		number++;//如果不是水仙花数，数字变量就累加1
    	} 
    	while (number < 1000);//while括号里的内容是他的限定范围
    
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2083.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2084.png)
    
    ---
    
    <aside>
    🏆 代码应用——for循环语句
    
    </aside>
    
    ```cpp
    //for语句
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	//起始表达式—不参加循环；对变量赋值，创建个变量等操作
    	//条件表达式—中止循环的条件
    	//末尾循环体—先执行循环语句，再运行末尾循环体
    	for (int b = 0; b < 10; b++)//起始表达式—不参加循环，可以对变量进行操作；条件表达式—中止条件；末尾循环体—循环操作
    	{
    		cout << b << endl;//循环语句
    	}//for 循环，想循环X次就让变量<X
    	system("pause");
    
    	return 0;
    
    }
    ```
    
    - for循环语句
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2085.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2086.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——for循环语句实际案例【猜数字】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	//起始表达式—不参加循环；对变量赋值，创建个变量等操作
    	//条件表达式—中止循环的条件
    	//末尾循环体—先执行循环语句，再运行末尾循环体
    	for (int b = 1; b < 101; b++)
    	{
    		if (b % 7 == 0 || b % 10 == 7 || b / 10 == 7)
    		{
    			cout << "数字为" << b << "敲桌子" << endl;//循环语句
    		}
    		else
    		{
    			cout << b << endl;//循环语句
    		}
    	}
    		
    system("pause");
    
    return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2087.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2088.png)
    
    ---
    
    <aside>
    🏆 代码应用——for嵌套循环
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	for (int i = 0; i < 10; i++)//外层执行一次，内层执行一个内循环【打印10列】
    	{
    		for (int j = 0; j < 10; j++)//打印一行星图【10个星号】【一行打印10个*】
    		{
    			cout << " ※ ";
    		}
    		cout << endl;
    	}
    	
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2089.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2090.png)
    
    ---
    
    <aside>
    🏆 代码应用——嵌套循环实际案例【乘法口诀表】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	for (int i = 1; i <10; i++)//外层执行一次，内层执行一个内循环
    	{
    		for (int j = 1; j <= i; j++)//打印一行星图【10个星号】
    		{
    			cout <<i<<"*"<<j<<"=" << i * j<<"\t";
    		}
    		cout << endl;
    	}
    	
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2091.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2092.png)
    
- C++程序流程结构——跳转结构【break、continue、go to无条件跳转】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    ---
    
    <aside>
    🏆 代码应用——breaak语句【跳出循环】
    
    </aside>
    
    ```cpp
    //break用法1：出现在switch语句中，用于退出switch
    #include<iostream>
    using namespace std;
    
    int main()
    {	
    	cout << "请选择副本难度" << endl;
    	cout << "1.简单" << endl;
    	cout << "2.中等" << endl;
    	cout << "3.困难" << endl;
    
    	int select=0;//创建用户选择变量
    	cin >> select;//等待用户输入
    
    	switch (select)
    	{
    	case 1:-//如果是选择1，输出结果1 
    		cout << "你选择的是简单难度" << endl;
    		break;//做结果1中断，执行完后到system("pause") 
    	case 2://如果是选择2，输出结果2 
    		cout << "你选择的是中等难度" << endl;
    		break;
    	case 3:
    		cout << "你选择的是困难难度" << endl;
    		break;
    	default://默认情况，不输入，执行后到system("pause")
    		break;
    	}
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    ```cpp
    //break用法2：出现在for循环语句中，跳出循环语句
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	for (int i = 0; i < 10; i++)
    	{
    		if (i == 5)//如果i等于5，退出循环
    		{
    			break;//当满足If条件后，运行break，直接跳出for循环
    		}
    		cout << i << endl;
    	}
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    ```cpp
    //break用法3：出现在forx循环嵌套结构中，退出内层循环
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	
    	for (int i = 0; i < 10; i++)
    	{
    		for (int j = 0; j < 10; j++)
    		{
    			if (j == 5)
    			{
    				break;//满足条件后，退出内层循环
    			}
    			cout << "※";
    		}
    		cout << endl;
    	}
    	system("pause");
    	return 0;
    }
    
    ```
    
    - break
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2093.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2094.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2095.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2096.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——continue语句【跳出本次循环，进入下一次循环】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	for (int i = 0; i < 100; i++)
    	{
    		if (i % 2 == 0)//如果是奇数，则输出；如果是偶数，则不输出
    		{
    			continue;//当满足If条件后，运行break，不再{....}运行下方代码，进入下一次循环指令for{....}
    		}
    		cout << i << endl;
    	}
    
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    - continue语句
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2097.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2098.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%2099.png)
    
    ---
    
    <aside>
    🏆 代码应用——go to 语句
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	cout << "这是第一行" << endl;
    	cout << "这是第二行" << endl;
    	goto flag;//无条件跳转到标志位
    	cout << "这是第三行" << endl;
    	cout << "这是第四行" << endl;
    	flag://标志位
    	cout << "这是第五行" << endl;
    	
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    - go to语句
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20100.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20101.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20102.png)
    
    ---
    
- C++数组【一维数组定义方式、一维数组内存大小&首地址、数组元素逆置、二维数组定义方式、二维数组内存大小&行列数&首地址】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——1维数组定义方式
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[5];//第一种数组定义方式：数据类型 数组名字[数组长度];
    
    	arr[0] = 10;//对数组中每个元素进行赋值，注意！！！【数组元素的下标是从0开始索引】
    	arr[1] = 20;
    	arr[2] = 30;
    	arr[3] = 40;
    	arr[4] = 50;
    
    	for (int i = 0; i < 5; i++)//遍历数组元素
    	{
    		cout << arr[i] << endl;
    	}
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr2[5] = {10,20,30,40,50};//第二种数组定义方式：数据类型 数组名字[数组长度]={元素值1，元素值2...，最后一个元素值}
    	//若未定义满5个值，未定义元素为0
    	for (int i = 0; i < 5; i++)//遍历数组元素
    	{
    		cout << arr[i] << endl;
    	}
    	system("pause");
    
    	return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr3[] = {10,20,30,40,50};//第三种数组定义方式：数据类型 数组名字[]={元素值1，元素值2...，最后一个元素值}
    	//定义数组时候必须要有初试长度，即定义个数为数组元素个数;否则报错
    	for (int i = 0; i < 5; i++)//遍历数组元素
    	{
    		cout << arr[i] << endl;
    	}
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    - 数组特点
        1. 放在一块连续的内存空间中
        2. 数组中每个元素都是相同数据类型
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20103.png)
        
    - 数组定义方法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20104.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20105.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20106.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20107.png)
    
    ---
    
    <aside>
    🏆 代码应用——1维数组内存大小&首地址
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
    
    	cout << "整个数组占用内存空间为：" << sizeof(arr) << endl; //统计数组所占内存空间
    	cout << "数组中每个元素占用内存空间为：" << sizeof(arr[0]) << endl;//统计单个元素所占用的内存空间
    	cout << "整个数组包含的元素个数：" << sizeof(arr) / sizeof(arr[0]) << endl;//统计数组中所包含的元素个数
    
    	cout << "数组首地址为：" <<(int)arr << endl;//查看数组首地址,int()把地址转换成10进制
    	cout << "数组中某个元素地址为" << (int)&arr[2] << endl;//查看某个元素的首地址,int()把地址转换成10进制
    	//数组名是常量，不可以进行赋值操作
    	//此处的&的取地址操作符【&的三种用法——1.取地址操作符、2.引用声明、3，按位与操作符】】
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    - 一维数组应用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20108.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20109.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20110.png)
        
    - &的不同含义
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20111.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——数组实际案例【五只小猪称体重】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[] = {300,350,200,400,250};
    	
    	int max = 0;//先定义一个最大值变量
    	for(int i = 0;i < 5;i++ )//如果访问的数组中的元素比定义的最大值大，则更新最大值
    	{
    		if (arr[i] > max)
    		{
    			max = arr[i];
    		}
    	}
    	cout << "最重的小猪的体重为：" << max << endl;
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20112.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20113.png)
    
    ---
    
    <aside>
    🏆 代码应用——数组实际案例【数组元素逆置】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[] = {3,5,2,4,1};//创建数组
    
    	cout << "数组逆置前:";//逆置前打印
    	for (int i = 0; i < 5; i++)
    	{
    		cout << arr[i] << "\t";
    	}
    	cout << endl;
    	
    	//实现元素互换
    	int start = 0;//记录起始下标位置
    	int end = sizeof(arr) / sizeof(arr[0]) - 1;//记录结束下标位置
    
    	while (start<end)
    	{
    		int temp = arr[start];//将起始值转移至临时存放处【数组元素互换标准结构】
    		arr[start] = arr[end];//将末尾值转移至起始值位置
    		arr[end] = temp;//将临时存放处数据存入末尾位置
    		start++;
    		end--;
    	}
    	cout << "数组逆置后:";
    	for (int i = 0; i < 5; i++)
    		{
    			cout << arr[i] << "\t";
    		}
    	cout << endl;
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20114.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20115.png)
    
    ---
    
    <aside>
    🏆 代码应用——一维数组【冒泡排序】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[] = { 4,2,8,0,5,7,1,3,9 };//定义数组
    
    	cout << "排序前数组结果：" << endl;//打印排序数组结果
    	for (int i = 0; i < 9; i++)
    	{
    		cout << arr[i] << "\t";
    	}
    	cout << endl;
    	
    	for (int i=0;i<9-1;i++)//外部循环控制排序轮数i=元素个数减1【i】
    	{
    		//内层循环控制排序次数j=元素个数-当前排序轮数i-1【i的作用——是不需要在后续的轮次中再次比较这些已经排好序的元素】
    		for (int j = 0; j < 9 - i - 1; j++)
    		{
    			if (arr[j] > arr[j + 1])
    			{
    				int temp = arr[j];
    				arr[j] = arr[j + 1];
    				arr[j + 1] = temp;
    			}
    		}
    	}
    	cout << "排序后数组结果：" << endl;//打印排序数组结果
    	for (int i = 0; i < 9; i++)
    	{
    		cout << arr[i] << "\t";
    	}
    	cout << endl;
    
    	system("pause");
    
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20116.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20117.png)
    
    ---
    
    <aside>
    🏆 代码应用——2维数组的定义方式
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[2][3] ;//第一种定义方式： 数据类型  数据名[行数][列数];
    
    	arr[0][0] = 30;//定义二维数组中每个变量的值
    	arr[0][1] = 40;
    	arr[0][2] = 90;
    	arr[1][0] = 50;
    	arr[1][1] = 60;
    	arr[1][2] = 80;
    	
    	for (int i = 0; i < 2; i++)
    	{
    		for (int j = 0; j <3 ; j++)
    		{
    			cout << arr[i][j] << endl;
    		}
    	}
    
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[2][3] = { {30,40,90},{50,60,80} };//第二种定义方式： 数据类型  数据名[行数][列数]={{数据1，数据2},{数据1，数据2}};
    
    	for (int i = 0; i < 2; i++)
    	{
    		for (int j = 0; j <3 ; j++)
    		{
    			cout << arr[i][j] << endl;
    		}
    	}
    
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[2][3] = { 30,40,90,50,60,80};//第三种定义方式： 数据类型  数据名[行数][列数]={数据1，数据2,数据3，数据4};
    
    	for (int i = 0; i < 2; i++)
    	{
    		for (int j = 0; j <3 ; j++)
    		{
    			cout << arr[i][j] << " ";
    		}
    		cout << endl;
    	}
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[][3] = { 30,40,90,50,60,80};//第四种定义方式： 数据类型  数据名[][列数]={数据1，数据2,数据3，数据4};
    
    	for (int i = 0; i < 2; i++)
    	{
    		for (int j = 0; j <3 ; j++)
    		{
    			cout << arr[i][j] << " ";
    		}
    		cout << endl;
    	}
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20118.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20119.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20119.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20119.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20119.png)
    
    ---
    
    <aside>
    🏆 代码应用——2维数组、每行、每个元素所占内存大小&首地址
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int arr[2][3] = { {30,40,90},{50,60,80} };
    	//查看二维数组所占内存空间 
    	cout <<"二维数组所占用的内存:" << sizeof(arr) << endl;//统计二维数组所占用的内存
    	cout <<"二维数组每行占用的内存:" << sizeof(arr[0]) << endl;//统计二维数组每一行占用的内存
    	cout <<"二维数组每个元素占用的内存:" << sizeof(arr[0][0]) << endl;//统计二维数组每个元素占用的内存
    
    	cout<<"二维数组包含的行数:"<< sizeof(arr) / sizeof(arr[0]) << endl;//计算二维数组所包含的行数
    	cout << "二维数组包含列数:" << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;
    	cout<<"二维数组包含的元素个数:"<< sizeof(arr)/ sizeof(arr[0][0]) << endl;//计算二维数组所包含元素个数
    
    	//获取二维数组首地址
    	cout<< "二维数组首地址为：" << (int)arr << endl;//获取二维数组首地址
    	cout<< "二维数组中某行首地址为：" << (int)arr[1] << endl;//获取二维数组某行首地址
    	cout << "二维数组中某行某列首地址为：" << (int)&arr[1][1] << endl;//获取二维数组某个元素首地址
    
    	system("pause");
    	return 0;
    }
    ```
    
    - 二维数组应用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20120.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20121.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——二位数组案例【成绩统计】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    int main()
    {
    	int arr[3][3] = { {100,100,100},{90,50,100},{60,70,80} };
    	string name[3] = { "张三","李四","王五" };
    	for (int i = 0; i <3; i++)
    	{
    		int sum = 0;//定义总分变量
    		for (int j = 0; j < 3; j++)
    		{
    			sum+=arr[i][j];
    		}
    		cout<<name[i]<<"的总分为：" << sum<<endl;
    	}
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20122.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20123.png)
    
    ---
    
- C++函数【定义函数、函数调用、值传递&实参形参、函数常见类型、函数声明、函数分文件编写】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——函数定义【封装代码】
    
    </aside>
    
    ```cpp
     //实现传入一个加法函数，传入两个整形数据，计算数据相加结果并返回
    
    int add(int num1, int num2)//返回值类型【int】 函数名自取【add】 （函数列表）
    {
    	int sum = num1 + num2;//实现两个数相加
    	return sum;//返回相加总和	
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20124.png)
    
    - 函数的作用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20125.png)
        
    - 函数语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20126.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20127.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数调用【在main函数中调用其他定义的函数】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //定义加法函数
    int add(int num1, int num2)//返回值类型【int】 函数名自取【add】 （函数列表）
    {
    	int sum = num1 + num2;//实现两个数相加
    	return sum;//返回相加总和	
    }
    int main()
    {
    	//main函数中调用加法函数
    	int a = 10;//a,b为实际参数，而上方函数定义的Number1和number2没有真正参数，称为形参
    	int b = 20;//当调用函数时，实参的值会传给形参
    	int c = add(a, b);//调用add函数，定义一个C变量接收函数的返回值
    	cout << "c=" << c << endl;
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    - 函数调用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20128.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20129.png)
    
    ---
    
    <aside>
    🏆 代码应用——值传递【形参改变不会影响实参变化】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //定义交换函数【如果不需要返回值，返回值类型为void】
    void swap(int num1, int num2)//函数体中的为形参
    {
    cout << "交换前：" << endl;
    cout << "num1=" << num1 << endl;
    cout << "num2=" << num2 << endl;
    
    int temp = num1;
    num1 = num2;
    num2 = temp;
    
    cout << "交换后：" << endl;
    cout << "num1=" << num1 << endl;
    cout << "num2=" << num2 << endl;
    //当没有返回值时，return可以不写
    }
    int main()
    {
    int a = 10;//定义变量为实参
    int b = 20;
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    //值传递时，函数的形参发生变化，不会影响实参
    swap(a, b);
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    
    system("pause");
    return 0;
    }
    ```
    
    - 值传递
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20130.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20131.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20132.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数常见样式【无返均为void；有返则考虑返回值类型】
    
    </aside>
    
    ```cpp
    //无参无返
    void test1()
    {
    	cout << "这是无参无返案例" << endl;
    }
    
    int main()//无参无返函数调用
    {
    	test1();
    }
    ------------------------------------------------------------------------------------------------
    //有参无返
    void test2(int a)
    {
    	cout << "这是有参无返案例,其中a=：" <<a<< endl;
    }
    
    int main()//有参无返函数调用
    {
    	test2(100);//100为给a赋值
    }
    ------------------------------------------------------------------------------------------------
    //无参有返[例如返回值类型为整形int]
    int test3()
    {
    	cout << "这是无参有返案例" << endl;
    	return 1000; 
    }
    
    int main()//有参无返函数调用
    {
    	int num1=test3();//num1为接收返回值
    	cout<<"num1="<<num1<<endl;
    }
    -------------------------------------------------------------------------------------------------
    //有参有返[例如返回值类型为整形int]
    int test4(int a)
    {
    	cout << "这是有参有返案例,其中a=：" <<a<< endl;
    	return 100; 
    }
    
    int main()//有参有返函数调用
    {
    	int num2=test4(10000);//num1为接收返回值
    	cout<<"num2="<<num2<<endl;
    }
    ```
    
    - 函数常见样式
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20133.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数声明【用于提前告知函数的存在】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //函数申明——用于提前告知程序，该函数的存在
    int max(int a, int b);
    
    int main()
    {	
    	int num1 = 10;
    	int num2 = 20;
    	cout << max(num1, num2) << endl;
    	system("pause");
    	return 0;
    }
    
    //函数定义——定义比较函数，实现两个整形数字进行比较，返回较大值
    int max(int a, int b)
    {
    	return a > b ? a : b;
    }
    ```
    
    - 若要将定义函数放在main之后，main函数之前需要函数声明
    - 若要将定义函数放在main之前，不需要需要函数声明
    
    - 函数声明
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20134.png)
        
        - 函数声明语法【用于提前告知该函数的存在，声明可以多次】
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20135.png)
            
        - 函数定义语法
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20136.png)
            
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20137.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数分文件编写
    
    </aside>
    
    ```cpp
    //原来整个主文件
    #include<iostream>
    using namespace std;
    
    void swap(int a,int b);//函数声明【.h文件中】
    
    int main()//【主文件中】
    {
    	int a=10;
    	int b=20;
    	swap(a,b);
    	
    	system("pause");
    	return 0;
    }
    
    void swap(int a,int b)//函数定义【.cpp文件中】
    {
    	int temp=a;
    	a=b;
    	b=temp;
    	
    	cout << "a=" << a << endl;
    	cout << "b=" << b << endl;
    }
    ```
    
    ---
    
    ```cpp
    //主文件
    #include<iostream>
    using namespace std;
    #include"swap.h"
    
    int main()
    {
    	int a=10;
    	int b=20;
    	swap(a,b);
    	
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    //.h头文件——写函数的声明
    #include<iostream>
    using namespace std;
    
    void swap(int a,int b);//函数声明
    ```
    
    ```cpp
    //.cpp源文件中——写函数的定义
    #include "swap.h"
    
    void swap(int a,int b)//函数定义
    {
    	int temp=a;
    	a=b;
    	b=temp;
    	
    	cout << "a=" << a << endl;
    	cout << "b=" << b << endl;
    }
    ```
    
    - 函数分文件编写
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20138.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20139.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20140.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20141.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20142.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20143.png)
        
    
    ---
    
- C++指针【指针的定义&引用、指针所占内存空间、空指针&野指针、修饰指针、指针数组联用、指针函数联用、指针数组函数联用案例】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——指针定义【通过指针保存地址；再通过地址调用参数】
    
    </aside>
    
    ```cpp
     #include<iostream>
    using namespace std;
    
    int main()
    {
    
    	int a=10;//定义变量
    	int *p;//定义指针
    	p=&a;//使指针取a的地址【&a表示取a的地址】
    	cout<<"a的地址为："<<&a<<endl;
    	cout<<"指针P为："<<p<<endl;
    
    	//使用指针——在指针前加*代表解引用，找到指针指向的内存数据【可进行访问和修改】
    	cout<<"*p"<<*p<<endl;//访问内存数据【*p表示取p指针内部对应的值】
    	
    	*p=1000;//修改内存数据
    	cout<<"a="<<a<<endl;
    	cout<<"*p"<<*p<<endl;
    	
    	system("pause");
    
    		return 0;
    }
    ```
    
    - 指针定义
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20144.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20145.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20146.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——指针所占的内存空间【】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    
    	int a = 10;//定义变量
    	int* p;//定义指针
    	p = &a;//使指针取a的地址【&a表示取a的地址】
    	cout << "a的地址为：" << &a << endl;
    	cout << "指针P为：" << p << endl;
    
    	//统计指针所占内存空间,不过什么数据类型，32位系统指针所占内存为4字节，64位所占内存为8字节
    	cout << "sizeof(int *)所占内存空间：" << sizeof(p) << endl;
    	cout << "sizeof(float *)所占内存空间：" << sizeof(p) << endl;
    	cout << "sizeof(double *)所占内存空间：" << sizeof(p) << endl;
    	cout << "sizeof(char *)所占内存空间：" << sizeof(p) << endl;
    
    	system("pause");
    
    	return 0;
    }
    ```
    
    - 指针所占的内存空间
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20147.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20148.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——空指针【用于初始化指针变量】
    
    </aside>
    
    ```cpp
    int main()
    {
    	int *p = NULL;//空指针用于给指针变量进行初始化[指针p对应的内容为空]
    
    	//*p=100;【0—255空指针为系统占用内存，不可以进行访问】
    	
    	
    	system("pause");
    	return 0;
    }
    ```
    
    - 空指针
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20149.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——野指针
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int *p = (int *)0X1100;//指针变量p指向内存地址编号为0X1100的非定义空间
    
    	//cout<<*p<<endl;【访问野指针报错】
    
    	system("pause");
    
    	return 0;
    }
    ```
    
    - 野指针
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20150.png)
        
    
    <aside>
    🏆 代码应用——const修饰指针
    
    </aside>
    
    ```cpp
    //修饰指针【可以改指向，不可以改指针指向的值】
    const int*p=&a;
    
    *p=20;//错误的，指针里的值不可以更改
    p=&b;//正确的，可以改变指针指向
    ```
    
    ```cpp
    //修饰常量【可以改指针指向的值，不可以改指针的指向】
    int * const p=&a;
    
    *p=20;//正确的，可以改变指针里的值
    p=&b;//错误的，指针指向不可以更改
    ```
    
    ```cpp
    //即修饰指针，又修饰常量【指针指向&指针指向的值都不可以更改】
    const int* const p=&a;
    
    *p=20;//错误的，指针里的值不可以更改
    p=&b;//错误的，指针指向不可以更改
    ```
    
    - const修饰指针
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20151.png)
        
        - 修饰指针
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20152.png)
            
        - 修饰常量
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20153.png)
            
        - 即修饰指针，又修饰常量
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20154.png)
            
        
    
    ---
    
    <aside>
    🏆 代码应用——指针&数组联用【利用指针访问数组中元素】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	//利用数组名称【元素】访问数组中的元素
    	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
    	cout << "第1个元素为：" << arr[0] << endl;
    	//利用指针访问数组中的元素
    	int* p = arr;//arr为数组首地址
    	for (int i = 0; i < 10; i++)
    	{
    		
    		cout << "第" << i + 1 << "个元素为：" << *p << endl;
    		p++;//让指针向后偏移8个字节，【即64位系统下，一个整形类型的地址所占的内存空间】
    	}
    
    	system("pause");
    
    	return 0;
    }
    ```
    
    - 指针&数组联用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20155.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20156.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——指针&函数联用【利用地址传递改变实参数据】
    
    </aside>
    
    ```cpp
    //值传递——值传递不会改变实参
    #include<iostream>
    using namespace std;
    
    //定义交换函数【如果不需要返回值，返回值类型为void】
    void swap(int num1, int num2)
    {
    int temp = num1;
    num1 = num2;
    num2 = temp;
    cout << "swap函数中虚参num1=" << num1 << endl;
    cout << "swap函数中虚参num2=" << num2 << endl;
    }
    
    int main()
    {
    int a = 10;
    int b = 20;
    
    swap(a, b);
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    
    system("pause");
    return 0;
    }
    ```
    
    ```cpp
    //地址传递——地址传递会改变实参
    #include<iostream>
    using namespace std;
    
    //定义交换函数【如果不需要返回值，返回值类型为void】
    void swap2(int *p1, int *p2)//通过*p1和*p2接收传入的数据
    {
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
    }
    
    int main()
    {
    int a = 10;
    int b = 20;
    
    swap2(&a, &b);//调用实参a和b的地址
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    
    system("pause");
    return 0;
    }
    ```
    
    - 指针&函数联用
        - 值传递
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20157.png)
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20158.png)
            
        - 地址传递
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20159.png)
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20160.png)
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20161.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——指针&数组&函数联用案例【冒泡排序】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    void bubblesort(int *arr, int len)//创建函数，实现冒泡排序功能（数组首地址，数组长度）
    {
    	for (int i = 0; i <len - 1; i++)
    	{
    		for (int j = 0; j < len - i - 1; j++)
    		{
    			if (arr[j] > arr[j + 1])
    			{
    				int temp = arr[j];
    				arr[j] = arr[j + 1];
    				arr[j + 1] = temp;
    			}
    		}
    	}
    }
    
    void printArray(int* arr, int len)//打印数组
    {
    	for (int i = 0; i < len; i++)
    	{
    		cout << arr[i] << endl;
    	}
    }
    
    int main()
    {
    	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };//创建一个数组
    	int len = sizeof(arr) / sizeof(arr[0]);//计算数组长度
    	bubblesort(arr, len);
    	printArray(arr, len);
    
    	system("pause");
    	return 0;
    }
    ```
    
    - 指针&数组&函数联用案例
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20162.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20163.png)
    
    ---
    
- C++结构体【定义结构体、结构体数组、结构体指针、结构体嵌套、结构体函数、结构体中const应用、结构体案例】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——结构体的定义和使用
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student //定义结构体成员列表中所包含的内容【此处struct关键字不可省略】
    {
    	string name;
    	int age;
    	int score;
    };
    
    int main()
    {
    	struct student s1;//创建结构体变量【此处struct关键字可省略】
    	s1.name = "张山";//给结构体变量赋值
    	s1.age = 26;
    	s1.score = 85;
    	cout << "姓名:" << s1.name << "年龄:" << s1.age << "分数:" << s1.score << endl;
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student 
    {
    	string name;
    	int age;
    	int score;
    };
    
    int main()
    {
    	struct student s2 = { "李四",28,95 };//创建结构体变量,并给其赋值1
    	cout << "姓名:" << s2.name << "年龄:" << s2.age << "分数:" << s2.score << endl;
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student 
    {
    	string name;
    	int age;
    	int score;
    }s3;//顺便创建结构体变量
    
    int main()
    {
    	s3.name = "王五";//给结构体变量赋值
    	s3.age = 30;
    	s3.score = 60;
    	cout << "姓名:" << s2.name << "年龄:" << s2.age << "分数:" << s2.score << endl;
    	system("pause");
    	return 0;
    }
    ```
    
    - 结构体
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20164.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20165.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20166.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20167.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20168.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——结构体数组
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student //定义结构体成员列表中所包含的内容【此处struct关键字不可省略】
    {
    	string name;
    	int age;
    	int score;
    };
    
    int main()
    {
    	struct student stuarry[3] = { {"张山",19,90},{"李四",25,85},{"王五",30,80} };//给结构体数组元素进行初始赋值
    	
    	stuarry[0].name = "老六";//给结构体数组元素修改赋值
    	stuarry[1].age = 35;
    	stuarry[2].score = 75;
    	for (int i=0; i < 3; i++)
    	{
    			cout << "姓名:" << stuarry[i].name << "年龄:" << stuarry[i].age << "分数:" << stuarry[i].score << endl;
    	}
    
    	system("pause");
    	return 0;
    }
    ```
    
    - 结构体数组
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20169.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20170.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——结构体指针
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student //定义结构体成员列表中所包含的内容【此处struct关键字不可省略】
    {
    string name;
    int age;
    int score;
    };
    
    int main()
    {
    struct student stu = { "张三",18,100 };//创建结构体变量
    struct student * p = &stu;//定义结构体指针p【struct 结构体名 * p=地址；此处*号为定义语法，而非解引用】
    p->score = 75;//通过->操作符修改成员属性
    cout << "姓名:" << p->name << "年龄:" << p->age << "分数:" << p->score << endl;
    
    system("pause");
    return 0;
    }
    ```
    
    - 结构体指针
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20171.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20172.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——结构体嵌套
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student //定义学生结构体
    {
    	string name;
    	int age;
    	int score;
    };
    
    struct teacher//定义老师结构体
    {
    	int id;
    	string name;
    	int age;
    	struct student stu;//关联另一个结构体【关联结构体应在该结构体的上方】
    };
    
    int main()
    {
    	struct teacher  tea = { 1102,"张老师",18,{"张三",25,80}};//给结构体变量赋值
    	cout << "教师编号:" << tea.id << "姓名:" << tea.name << "年龄:" << tea.age << "辅导学生:" << tea.stu.name << "辅导学生年龄:" << tea.stu.age << "辅导学生分数:" << tea.stu.score << endl;
    
    	system("pause");
    	return 0;
    }
    ```
    
    - 结构体嵌套
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20173.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20174.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20175.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——结构体做函数参数
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student //定义学生结构体
    {
    	string name;
    	int age;
    	int score;
    };
    
    void printstudent1(struct student stu)//值传递方式——改变形参，main函数中实参不发生改变
    {
    	stu.age = 100;//形参发生改变
    	cout << "值传递中姓名:" << stu.name << "年龄 : " << stu.age << "分数 : " << stu.score << endl;
    }
    
    int main()
    {
    	struct student stu = {"张三",25,80};//给结构体变量赋值
    	printstudent1(stu);
    	cout << "main姓名:" << stu.name << "年龄 : " << stu.age << "分数 : " << stu.score << endl;//实参不发生改变
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student //定义学生结构体
    {
    	string name;
    	int age;
    	int score;
    };
    
    void printstudent2(struct student *p)//地址传递方式——改变形参，main函数中实参发生改变
    {
    	p->age = 50;//形参发生改变
    	cout << "地址传递中姓名:" << p->name << "年龄 : " << p->age << "分数 : " << p->score << endl;//形参发生改变
    }
    
    int main()
    {
    	struct student stu = { "张三",25,80 };//给结构体变量赋值
    	printstudent2(&stu);
    	cout << "main姓名:" << stu.name << "年龄 : " << stu.age << "分数 : " << stu.score << endl;//实参
    	system("pause");
    	return 0;
    }
    ```
    
    - 结构体做函数参数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20176.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20177.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20178.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——结构体中const使用场景
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct student //定义学生结构体
    {
    	string name;
    	int age;
    	int score;
    };
    //为了减少占用的内存空间，一般采用地址传递的方式【即采用指针】
    void printstudent1(const student *p)//加入const，防止误操作
    {
    	//p->age = 100; 【加入const 之后，修改的操作就会报错，防止误操作。】
    	cout << "加入const后姓名:" << p->name << "年龄 : " << p->age << "分数 : " << p->score << endl;
    }
    
    int main()
    {
    	student stu = { "张三",25,80 };//给结构体变量赋值
    	printstudent1(&stu);
    	cout << "main姓名:" << stu.name << "年龄 : " << stu.age << "分数 : " << stu.score << endl;
    	system("pause");
    	return 0;
    }
    ```
    
    - 结构体中const使用场景
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20179.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20180.png)
    
    ---
    
    <aside>
    🏆 代码应用——结构体案例1【毕业设计】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    //string数据类型所包含的头文件
    #include<ctime>
    //随机数种子所包含的头文件
    
    struct student//学生的结构体—包括学生姓名，分数
    {
    	string sname;
    	int score;	
    };
    struct teacher //老师的结构体—包括老师姓名，学生数组
    {
    	string tname;
    	struct student stuarry[5];
    };
    void allocatespace(struct teacher teaarray[], int len)//通过函数给老师和学生信息进行赋值
    {
    	string nameseed = "ABCDE";
    	for (int i = 0; i < len; i++)//外侧循环给每名老师赋值
    	{
    		teaarray[i].tname = "Teacher_";
    		teaarray[i].tname += nameseed[i];
    		for (int j = 0; j < 5; j++)//内侧循环给每名老师所带的学生赋值
    		{
    			teaarray[i].stuarry[j].sname = "Student_";
    			teaarray[i].stuarry[j].sname += nameseed[j];
    
    			int random = rand() % 100 + 1;//1~100随机生成数字
    			teaarray[i].stuarry[j].score = random;
    		}
    	}
    
    }
    void printinfo(struct teacher teaarray[], int len)//通过函数打印所有老师和学生信息
    {
    	for (int i = 0; i < len; i++)
    	{
    		cout << "老师姓名" << teaarray[i].tname << endl;
    		for (int j = 0; j < 5; j++)
    		{
    			cout << "\t学生姓名" << teaarray[i].stuarry[j].sname << "考试分数" << teaarray[i].stuarry[j].score<<endl;
    		}
    	}
    }
    int main()
    {
    	srand((unsigned int)time(NULL));//生成随机数种子
    	
    	struct teacher teaarry[3];//创建3名老师的数组
    	int len = sizeof(teaarry) / sizeof(teaarry[0]);//通过一个函数，给3名老师的信息进行赋值，并给老师带的学生进行赋值
    	allocatespace(teaarry, len);
    	printinfo(teaarry, len);
    	system("pause");
    	return 0;
    }
    ```
    
    - 结构体案例
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20181.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20182.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20183.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——结构体案例2【英雄冒泡排序】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    struct hero//定义英雄结构体—包括英雄姓名，年龄，性别
    {
    	string name;
    	int age;	
    	string sex;
    };
    
    void bubblesort(struct hero heroarray[], int len)//通过函数,实现年龄冒泡升序排列
    {
    	for (int i = 0; i < len-1; i++)
    	{
    		for (int j = 0; j < len-i-1; j++)
    		{
    			if (heroarray[j].age> heroarray[j+1].age)
    			{
    				hero temp = heroarray[j];
    				heroarray[j] = heroarray[j + 1];
    				heroarray[j + 1] = temp;
    			}
    		}
    	}
    }
    void printinfo(struct hero heroarray[], int len)//通过函数打印排序后数组信息
    {
    	cout << "排序后打印" << endl;
    	for (int i = 0; i < len; i++)
    	{
    		cout<<"姓名：" << heroarray[i].name << "年龄：" << heroarray[i].age << "性别：" << heroarray[i].sex << endl;
    	}
    }
    int main()
    {
    	
    	struct hero heroarray[5] = { {"刘备",23,"男"}, {"关羽",22,"男"},  {"张飞",20,"男"},  {"赵云",21,"男"},  {"貂蝉",19,"女"}};//创建5名英雄的数组，并给其赋值
    	int len = sizeof(heroarray) / sizeof(heroarray[0]);//通过一个函数，给3名老师的信息进行赋值，并给老师带的学生进行赋值
    	cout << "排序前打印" << endl;
    	for (int i = 0; i < len; i++)
    	{
    		cout << "姓名：" << heroarray[i].name << "年龄：" << heroarray[i].age << "性别：" << heroarray[i].sex << endl;
    	}
    
    	bubblesort(heroarray, len);
    	printinfo(heroarray, len);
    	
    	system("pause");
    	return 0;
    }
    ```
    
    - 结构体案例
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20184.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20185.png)
        
    
    ---
    
- C++基础综合案例——通讯录管理系统【设置显示菜单、退出通讯录功能、添加联系人功能、显示联系人功能、删除联系人功能、查找联系人功能、修改联系人功能、清空联系人】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20186.png)
    
    ---
    
    <aside>
    🏆 代码应用——显示菜单【封装函数&调用】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //1.显示菜单界面
    void showMenu()
    {
    	cout << "*************************" << endl;
    	cout << "*****1.添加联系人*****" << endl;
    	cout << "*****2.显示联系人*****" << endl;
    	cout << "*****3.删除联系人*****" << endl;
    	cout << "*****4.查找联系人*****" << endl;
    	cout << "*****5.修改联系人*****" << endl;
    	cout << "*****6.清空联系人*****" << endl;
    	cout << "*****0.退出通讯录*****" << endl;
    	cout << "*************************" << endl;
    }
    int main()
    {
    	//调用显示菜单界面
    	showMenu();
    
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20187.png)
    
    - 菜单功能
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20188.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——退出通讯录功能【选择结构、while循环】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //1.显示菜单界面
    void showMenu()
    {
    	cout << "*************************" << endl;
    	cout << "*****1.添加联系人*****" << endl;
    	cout << "*****2.显示联系人*****" << endl;
    	cout << "*****3.删除联系人*****" << endl;
    	cout << "*****4.查找联系人*****" << endl;
    	cout << "*****5.修改联系人*****" << endl;
    	cout << "*****6.清空联系人*****" << endl;
    	cout << "*****0.退出通讯录*****" << endl;
    	cout << "*************************" << endl;
    }
    int main()
    {
    	
    	int select = 0;//创建用户选择变量
    	
    	while (true)//设置循环，当结果为0时，则退出通讯录；否则仍然在通讯录里循环
    	{
    		showMenu();//调用显示菜单界面
    		cin >> select;//用户输入选择结果
    		//用户选择分支架构
    		switch (select)
    		{
    		case 1://1.添加联系人
    			break;
    		case 2://2.显示联系人
    			break;
    		case 3://3.删除联系人
    			break;
    		case 4://4.查找联系人
    			break;
    		case 5://5.修改联系人
    			break;
    		case 6://6.清空联系人
    			break;
    		default://0.退出通讯录
    			cout << "欢迎下次使用" << endl;
    			system("pause");
    			return 0;
    			break;
    		}
    	}
    	
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20189.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20190.png)
    
    ---
    
    <aside>
    🏆 代码应用——添加联系人功能
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    #define MAX 1000//设置最大人数为1000
    
    struct contacts//联系人结构体
    {
    	string name;//姓名
    	int sex;//性别(男生为1，女生为0)
    	int age;//年龄
    	string telephone;//电话号码
    	string address;//住址
    };
    
    struct directory//通讯录结构体
    {
    	struct contacts personArray[MAX];//通讯录现存联系人数组
    	int size;//通讯录现存人员个数
    };
    
    void addcontacts(directory* abs)//添加联系人函数
    {
    	if (abs->size == MAX)//如果现存函数已达存取上限，则无法添加
    	{
    		cout << "通讯录已满，无法添加！" << endl;
    		return;
    	}
    	else//如果现存函数未达到存取上限，可继续添加
    	{
    		//姓名
    		cout << "请输入姓名：" << endl;
    		string name;//姓名
    		cin >> name;
    		abs->personArray[abs->size].name = name;
    		//性别
    		cout << "请输入性别（1为男生，2为女生）" << endl;
    		int sex = 0;
    		while (true)//如果输入的是1或者2则退出循环，否则卡在死循环直到输对为止
    		{
    			cin >> sex;
    			if (sex == 1 or sex == 2)
    			{
    				abs->personArray[abs->size].sex = sex;
    				break;
    			}
    			cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    		}
    		//年龄
    		cout << "请输入年龄" << endl;
    		int age = 0;
    		cin >> age;
    		abs->personArray[abs->size].age = age;
    		//电话号码
    		cout << "请输入电话号码" << endl;
    		string telephone;
    		cin >> telephone;
    		abs->personArray[abs->size].telephone = telephone;
    		//地址
    		cout << "请输入住址" << endl;
    		string address;
    		cin >> address;
    		abs->personArray[abs->size].address = address;
    		//更新通讯录人数
    		abs->size++;
    		cout << "添加成功" << endl;
    		//清屏
    		system("pause");//请按任意键继续
    		system("cls");//清屏操作
    	}
    };
    //1.显示菜单界面
    void showMenu()
    {
    	cout << "*************************" << endl;
    	cout << "*****1.添加联系人*****" << endl;
    	cout << "*****2.显示联系人*****" << endl;
    	cout << "*****3.删除联系人*****" << endl;
    	cout << "*****4.查找联系人*****" << endl;
    	cout << "*****5.修改联系人*****" << endl;
    	cout << "*****6.清空联系人*****" << endl;
    	cout << "*****0.退出通讯录*****" << endl;
    	cout << "*************************" << endl;
    }
    int main()
    {
    	directory abs;//创建通讯录结构体变量
    	abs.size = 0;//初始化通讯录当前人员个数
    	
    	int select = 0;//创建用户选择变量
    	
    	while (true)//设置循环，当结果为0时，则退出通讯录；否则仍然在通讯录里循环
    	{
    		showMenu();//调用显示菜单界面
    		cin >> select;//用户输入选择结果
    		//用户选择分支架构
    		switch (select)
    		{
    		case 1://1.添加联系人
    			addcontacts(&abs);//添加联系人函数—利用地址传递修改实参【由于值传递无法修改实参，因此选用地址传递】
    			break;
    		case 2://2.显示联系人
    			break;
    		case 3://3.删除联系人
    			break;
    		case 4://4.查找联系人
    			break;
    		case 5://5.修改联系人
    			break;
    		case 6://6.清空联系人
    			break;
    		default://0.退出通讯录
    			cout << "欢迎下次使用" << endl;
    			system("pause");
    			return 0;
    			break;
    		}
    	}
    	
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20191.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20192.png)
    
    - 设计联系人结构体
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20193.png)
        
    - 设计通讯录结构体
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20194.png)
        
    - main函数创建通讯录
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20195.png)
        
    - 封装添加联系人函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20196.png)
        
    - 测试添加联系人功能
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20197.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——显示联系人功能
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    #define MAX 1000//设置最大人数为1000
    
    struct contacts//联系人结构体
    {
    	string name;//姓名
    	int sex;//性别(男生为1，女生为0)
    	int age;//年龄
    	string telephone;//电话号码
    	string address;//住址
    };
    
    struct directory//通讯录结构体
    {
    	struct contacts personArray[MAX];//通讯录现存联系人数组
    	int size;//通讯录现存人员个数
    };
    
    void addcontacts(directory* abs)//添加联系人函数
    {
    	//如果现存函数已达存取上限，则无法添加；如果现存函数未达到存取上限，可继续添加
    	if (abs->size == MAX)//如果现存函数已达存取上限，则无法添加
    	{
    		cout << "通讯录已满，无法添加！" << endl;
    		return;
    	}
    	else//如果现存函数未达到存取上限，可继续添加
    	{
    		//姓名
    		cout << "请输入姓名：" << endl;
    		string name;//姓名
    		cin >> name;
    		abs->personArray[abs->size].name = name;
    		//性别
    		cout << "请输入性别（1为男生，2为女生）" << endl;
    		int sex = 0;
    		while (true)//如果输入的是1或者2则退出循环，否则卡在死循环直到输对为止
    		{
    			cin >> sex;
    			if (sex == 1 or sex == 2)
    			{
    				abs->personArray[abs->size].sex = sex;
    				break;
    			}
    			cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    		}
    		//年龄
    		cout << "请输入年龄" << endl;
    		int age = 0;
    		cin >> age;
    		abs->personArray[abs->size].age = age;
    		//电话号码
    		cout << "请输入电话号码" << endl;
    		string telephone;
    		cin >> telephone;
    		abs->personArray[abs->size].telephone = telephone;
    		//地址
    		cout << "请输入住址" << endl;
    		string address;
    		cin >> address;
    		abs->personArray[abs->size].address = address;
    		//更新通讯录人数
    		abs->size++;
    		cout << "添加成功" << endl;
    		//清屏
    		system("pause");//请按任意键继续
    		system("cls");//清屏操作
    	}
    };
    void showcontacts(directory* abs)//显示所有联系人
    {
    	//判断通讯录人数是否为0，如果为0，提示记录为空；如果不为0，显示记录的联系人信息
    	if (abs->size == 0)//如果为0，提示记录为空；
    	{
    		cout << "当前记录为空" << endl;
    	}
    	else//如果不为0，采用遍历的方法—显示记录的联系人信息；
    	{
    		for (int i = 0; i < abs->size; i++)
    		{
    			cout << "姓名:" << abs->personArray[i].name << "\t";
    			cout << "性别:" << (abs->personArray[i].sex == 1 ? "男" : "女") << "\t";
    			cout << "年龄:" << abs->personArray[i].age << "\t";
    			cout << "电话号码:" << abs->personArray[i].telephone << "\t";
    			cout << "地址:" << abs->personArray[i].address << endl;
    		}
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    
    //1.显示菜单界面
    void showMenu()
    {
    	cout << "*************************" << endl;
    	cout << "*****1.添加联系人*****" << endl;
    	cout << "*****2.显示联系人*****" << endl;
    	cout << "*****3.删除联系人*****" << endl;
    	cout << "*****4.查找联系人*****" << endl;
    	cout << "*****5.修改联系人*****" << endl;
    	cout << "*****6.清空联系人*****" << endl;
    	cout << "*****0.退出通讯录*****" << endl;
    	cout << "*************************" << endl;
    }
    int main()
    {
    	directory abs;//创建通讯录结构体变量
    	abs.size = 0;//初始化通讯录当前人员个数
    	
    	int select = 0;//创建用户选择变量
    	
    	while (true)//设置循环，当结果为0时，则退出通讯录；否则仍然在通讯录里循环
    	{
    		showMenu();//调用显示菜单界面
    		cin >> select;//用户输入选择结果
    		//用户选择分支架构
    		switch (select)
    		{
    		case 1://1.添加联系人
    			addcontacts(&abs);//添加联系人函数—利用地址传递修改实参【由于值传递无法修改实参，因此选用地址传递】
    			break;
    		case 2://2.显示联系人
    			showcontacts(&abs);//显示联系人函数—利用地址传递修改实参【由于值传递无法修改实参，因此选用地址传递】
    			break;
    		case 3://3.删除联系人
    			break;
    		case 4://4.查找联系人
    			break;
    		case 5://5.修改联系人
    			break;
    		case 6://6.清空联系人
    			break;
    		default://0.退出通讯录
    			cout << "欢迎下次使用" << endl;
    			system("pause");
    			return 0;
    			break;
    		}
    	}
    	
    	system("pause");
    	return 0;
    }
    ```
    
    - 封装显示联系人函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20198.png)
        
    - 测试显示联系人功能
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20199.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20200.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20201.png)
    
    ---
    
    <aside>
    🏆 代码应用——删除联系人
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    #define MAX 1000//设置最大人数为1000
    
    struct contacts//联系人结构体
    {
    	string name;//姓名
    	int sex;//性别(男生为1，女生为0)
    	int age;//年龄
    	string telephone;//电话号码
    	string address;//住址
    };
    
    struct directory//通讯录结构体
    {
    	struct contacts personArray[MAX];//通讯录现存联系人数组
    	int size;//通讯录现存人员个数
    };
    
    void addcontacts(directory* abs)//添加联系人函数
    {
    	//如果现存函数已达存取上限，则无法添加；如果现存函数未达到存取上限，可继续添加
    	if (abs->size == MAX)//如果现存函数已达存取上限，则无法添加
    	{
    		cout << "通讯录已满，无法添加！" << endl;
    		return;
    	}
    	else//如果现存函数未达到存取上限，可继续添加
    	{
    		//姓名
    		cout << "请输入姓名：" << endl;
    		string name;//姓名
    		cin >> name;
    		abs->personArray[abs->size].name = name;
    		//性别
    		cout << "请输入性别（1为男生，2为女生）" << endl;
    		int sex = 0;
    		while (true)//如果输入的是1或者2则退出循环，否则卡在死循环直到输对为止
    		{
    			cin >> sex;
    			if (sex == 1 or sex == 2)
    			{
    				abs->personArray[abs->size].sex = sex;
    				break;
    			}
    			cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    		}
    		//年龄
    		cout << "请输入年龄" << endl;
    		int age = 0;
    		cin >> age;
    		abs->personArray[abs->size].age = age;
    		//电话号码
    		cout << "请输入电话号码" << endl;
    		string telephone;
    		cin >> telephone;
    		abs->personArray[abs->size].telephone = telephone;
    		//地址
    		cout << "请输入住址" << endl;
    		string address;
    		cin >> address;
    		abs->personArray[abs->size].address = address;
    		//更新通讯录人数
    		abs->size++;
    		cout << "添加成功" << endl;
    		//清屏
    		system("pause");//请按任意键继续
    		system("cls");//清屏操作
    	}
    };
    void showcontacts(directory* abs)//显示所有联系人
    {
    	//判断通讯录人数是否为0，如果为0，提示记录为空；如果不为0，显示记录的联系人信息
    	if (abs->size == 0)//如果为0，提示记录为空；
    	{
    		cout << "当前记录为空" << endl;
    	}
    	else//如果不为0，采用遍历的方法—显示记录的联系人信息；
    	{
    		for (int i = 0; i < abs->size; i++)
    		{
    			cout << "姓名:" << abs->personArray[i].name << "\t";
    			cout << "性别:" << (abs->personArray[i].sex == 1 ? "男" : "女") << "\t";
    			cout << "年龄:" << abs->personArray[i].age << "\t";
    			cout << "电话号码:" << abs->personArray[i].telephone << "\t";
    			cout << "地址:" << abs->personArray[i].address << endl;
    		}
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    int isexist(directory* abs,string name)//检测联系人是否存在【参数1—通讯录；参数2—对比数组中的姓名】
    {
    	//检测联系人是否存在，如果存在，返回联系人所在数组中的具体位置，不存在返回-1
    	for (int i = 0; i < abs->size; i++)//遍历数组中所有人的信息
    	{
    		if (abs->personArray[i].name == name)
    		{
    			return i;//如果存在，返回联系人所在数组中的具体位置
    		}
    	}
    	return -1;//不存在，返回-1	
    }
    void deletecontacts(directory*abs)//删除所选联系人
    {
    	cout << "请输入您要删除的用户" << endl;
    	string name;
    	cin >> name;
    	int ret = isexist(abs, name);
    	if (ret != -1)//若不等于-1，即查询到此人，进行删除操作
    	{
    		for (int i = ret; i < abs->size; i++)//删除某位数据，后续数据向前迁移
    		{
    			abs->personArray[i] = abs->personArray[i + 1];
    		}
    		abs->size--;//更新通讯录人数
    		cout << "删除成功" << endl;
    	}
    	else
    	{
    		cout << "查无此人" << endl;
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    //1.显示菜单界面
    void showMenu()
    {
    	cout << "*************************" << endl;
    	cout << "*****1.添加联系人*****" << endl;
    	cout << "*****2.显示联系人*****" << endl;
    	cout << "*****3.删除联系人*****" << endl;
    	cout << "*****4.查找联系人*****" << endl;
    	cout << "*****5.修改联系人*****" << endl;
    	cout << "*****6.清空联系人*****" << endl;
    	cout << "*****0.退出通讯录*****" << endl;
    	cout << "*************************" << endl;
    }
    int main()
    {
    	directory abs;//创建通讯录结构体变量
    	abs.size = 0;//初始化通讯录当前人员个数
    	
    	int select = 0;//创建用户选择变量
    	
    	while (true)//设置循环，当结果为0时，则退出通讯录；否则仍然在通讯录里循环
    	{
    		showMenu();//调用显示菜单界面
    		cin >> select;//用户输入选择结果
    		//用户选择分支架构
    		switch (select)
    		{
    		case 1://1.添加联系人
    			addcontacts(&abs);//添加联系人函数—利用地址传递修改实参【由于值传递无法修改实参，因此选用地址传递】
    			break;
    		case 2://2.显示联系人
    			showcontacts(&abs);//显示联系人函数
    			break;
    		case 3://3.删除联系人
    			deletecontacts(&abs);
    			break;
    		case 4://4.查找联系人
    			break;
    		case 5://5.修改联系人
    			break;
    		case 6://6.清空联系人
    			break;
    		default://0.退出通讯录
    			cout << "欢迎下次使用" << endl;
    			system("pause");
    			return 0;
    			break;
    		}
    	}
    	
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20202.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20203.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20204.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20205.png)
    
    - 封装检测联系人是否存在
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20206.png)
        
    - 封装删除联系人函数
    - 测试删除联系人功能
    
    ---
    
    <aside>
    🏆 代码应用——查找联系人
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    #define MAX 1000//设置最大人数为1000
    
    struct contacts//联系人结构体
    {
    	string name;//姓名
    	int sex;//性别(男生为1，女生为0)
    	int age;//年龄
    	string telephone;//电话号码
    	string address;//住址
    };
    
    struct directory//通讯录结构体
    {
    	struct contacts personArray[MAX];//通讯录现存联系人数组
    	int size;//通讯录现存人员个数
    };
    
    void addcontacts(directory* abs)//添加联系人函数
    {
    	//如果现存函数已达存取上限，则无法添加；如果现存函数未达到存取上限，可继续添加
    	if (abs->size == MAX)//如果现存函数已达存取上限，则无法添加
    	{
    		cout << "通讯录已满，无法添加！" << endl;
    		return;
    	}
    	else//如果现存函数未达到存取上限，可继续添加
    	{
    		//姓名
    		cout << "请输入姓名：" << endl;
    		string name;//姓名
    		cin >> name;
    		abs->personArray[abs->size].name = name;
    		//性别
    		cout << "请输入性别（1为男生，2为女生）" << endl;
    		int sex = 0;
    		while (true)//如果输入的是1或者2则退出循环，否则卡在死循环直到输对为止
    		{
    			cin >> sex;
    			if (sex == 1 or sex == 2)
    			{
    				abs->personArray[abs->size].sex = sex;
    				break;
    			}
    			cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    		}
    		//年龄
    		cout << "请输入年龄" << endl;
    		int age = 0;
    		cin >> age;
    		abs->personArray[abs->size].age = age;
    		//电话号码
    		cout << "请输入电话号码" << endl;
    		string telephone;
    		cin >> telephone;
    		abs->personArray[abs->size].telephone = telephone;
    		//地址
    		cout << "请输入住址" << endl;
    		string address;
    		cin >> address;
    		abs->personArray[abs->size].address = address;
    		//更新通讯录人数
    		abs->size++;
    		cout << "添加成功" << endl;
    		//清屏
    		system("pause");//请按任意键继续
    		system("cls");//清屏操作
    	}
    };
    void showcontacts(directory* abs)//显示所有联系人
    {
    	//判断通讯录人数是否为0，如果为0，提示记录为空；如果不为0，显示记录的联系人信息
    	if (abs->size == 0)//如果为0，提示记录为空；
    	{
    		cout << "当前记录为空" << endl;
    	}
    	else//如果不为0，采用遍历的方法—显示记录的联系人信息；
    	{
    		for (int i = 0; i < abs->size; i++)
    		{
    			cout << "姓名:" << abs->personArray[i].name << "\t";
    			cout << "性别:" << (abs->personArray[i].sex == 1 ? "男" : "女") << "\t";
    			cout << "年龄:" << abs->personArray[i].age << "\t";
    			cout << "电话号码:" << abs->personArray[i].telephone << "\t";
    			cout << "地址:" << abs->personArray[i].address << endl;
    		}
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    int isexist(directory* abs,string name)//检测联系人是否存在【参数1—通讯录；参数2—对比数组中的姓名】
    {
    	//检测联系人是否存在，如果存在，返回联系人所在数组中的具体位置，不存在返回-1
    	for (int i = 0; i < abs->size; i++)//遍历数组中所有人的信息
    	{
    		if (abs->personArray[i].name == name)
    		{
    			return i;//如果存在，返回联系人所在数组中的具体位置
    		}
    	}
    	return -1;//不存在，返回-1	
    }
    void deletecontacts(directory*abs)//删除所选联系人
    {
    	cout << "请输入您要删除的用户" << endl;
    	string name;
    	cin >> name;
    	int ret = isexist(abs, name);
    	if (ret != -1)//若不等于-1，即查询到此人，进行删除操作
    	{
    		for (int i = ret; i < abs->size; i++)//删除某位数据，后续数据向前迁移
    		{
    			abs->personArray[i] = abs->personArray[i + 1];
    		}
    		abs->size--;//更新通讯录人数
    		cout << "删除成功" << endl;
    	}
    	else
    	{
    		cout << "查无此人" << endl;
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    void checkcontacts(directory* abs)//查找所选联系人
    {
    	cout << "请输入您要查找的用户" << endl;
    	string name;
    	cin >> name;
    	int ret = isexist(abs, name);
    	if (ret != -1)//若不等于-1，即查询到此人，进行显示其信息
    	{
    		cout << "姓名:" << abs->personArray[ret].name << "\t";
    		cout << "性别:" << (abs->personArray[ret].sex == 1 ? "男" : "女") << "\t";
    		cout << "年龄:" << abs->personArray[ret].age << "\t";
    		cout << "电话号码:" << abs->personArray[ret].telephone << "\t";
    		cout << "地址:" << abs->personArray[ret].address << endl;
    	}
    	else
    	{
    		cout << "查无此人" << endl;
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    //1.显示菜单界面
    void showMenu()
    {
    	cout << "*************************" << endl;
    	cout << "*****1.添加联系人*****" << endl;
    	cout << "*****2.显示联系人*****" << endl;
    	cout << "*****3.删除联系人*****" << endl;
    	cout << "*****4.查找联系人*****" << endl;
    	cout << "*****5.修改联系人*****" << endl;
    	cout << "*****6.清空联系人*****" << endl;
    	cout << "*****0.退出通讯录*****" << endl;
    	cout << "*************************" << endl;
    }
    int main()
    {
    	directory abs;//创建通讯录结构体变量
    	abs.size = 0;//初始化通讯录当前人员个数
    	
    	int select = 0;//创建用户选择变量
    	
    	while (true)//设置循环，当结果为0时，则退出通讯录；否则仍然在通讯录里循环
    	{
    		showMenu();//调用显示菜单界面
    		cin >> select;//用户输入选择结果
    		//用户选择分支架构
    		switch (select)
    		{
    		case 1://1.添加联系人
    			addcontacts(&abs);//调用添加联系人函数—利用地址传递修改实参【由于值传递无法修改实参，因此选用地址传递】
    			break;
    		case 2://2.显示联系人
    			showcontacts(&abs);//调用显示联系人函数
    			break;
    		case 3://3.删除联系人
    			deletecontacts(&abs);//调用删除联系人函数
    			break;
    		case 4://4.查找联系人
    			checkcontacts(&abs);//调用查找联系人函数
    			break;
    		case 5://5.修改联系人
    			break;
    		case 6://6.清空联系人
    			break;
    		default://0.退出通讯录
    			cout << "欢迎下次使用" << endl;
    			system("pause");
    			return 0;
    			break;
    		}
    	}
    	
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20207.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20208.png)
    
    - 封装查找联系人函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20209.png)
        
    - 测试查找联系人
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20210.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——修改联系人
    
    </aside>
    
    ```bash
    #include<iostream>
    using namespace std;
    #include<string>
    #define MAX 1000//设置最大人数为1000
    
    struct contacts//联系人结构体
    {
    string name;//姓名
    int sex;//性别(男生为1，女生为0)
    int age;//年龄
    string telephone;//电话号码
    string address;//住址
    };
    struct directory//通讯录结构体
    {
    struct contacts personArray[MAX];//通讯录现存联系人数组
    int size;//通讯录现存人员个数
    };
    
    void addcontacts(directory* abs)//添加联系人函数
    {
    //如果现存函数已达存取上限，则无法添加；如果现存函数未达到存取上限，可继续添加
    if (abs->size == MAX)//如果现存函数已达存取上限，则无法添加
    {
    cout << "通讯录已满，无法添加！" << endl;
    return;
    }
    else//如果现存函数未达到存取上限，可继续添加
    {
    //姓名
    cout << "请输入姓名：" << endl;
    string name;//姓名
    cin >> name;
    abs->personArray[abs->size].name = name;
    //性别
    cout << "请输入性别（1为男生，2为女生）" << endl;
    int sex = 0;
    while (true)//如果输入的是1或者2则退出循环，否则卡在死循环直到输对为止
    {
    cin >> sex;
    if (sex == 1 or sex == 2)
    {
    abs->personArray[abs->size].sex = sex;
    break;
    }
    cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    }
    //年龄
    cout << "请输入年龄" << endl;
    int age = 0;
    cin >> age;
    abs->personArray[abs->size].age = age;
    //电话号码
    cout << "请输入电话号码" << endl;
    string telephone;
    cin >> telephone;
    abs->personArray[abs->size].telephone = telephone;
    //地址
    cout << "请输入住址" << endl;
    string address;
    cin >> address;
    abs->personArray[abs->size].address = address;
    //更新通讯录人数
    abs->size++;
    cout << "添加成功" << endl;
    //清屏
    system("pause");//请按任意键继续
    system("cls");//清屏操作
    }
    };
    void showcontacts(directory* abs)//显示所有联系人
    {
    //判断通讯录人数是否为0，如果为0，提示记录为空；如果不为0，显示记录的联系人信息
    if (abs->size == 0)//如果为0，提示记录为空；
    {
    cout << "当前记录为空" << endl;
    }
    else//如果不为0，采用遍历的方法—显示记录的联系人信息；
    {
    for (int i = 0; i < abs->size; i++)
    {
    cout << "姓名:" << abs->personArray[i].name << "\t";
    cout << "性别:" << (abs->personArray[i].sex == 1 ? "男" : "女") << "\t";
    cout << "年龄:" << abs->personArray[i].age << "\t";
    cout << "电话号码:" << abs->personArray[i].telephone << "\t";
    cout << "地址:" << abs->personArray[i].address << endl;
    }
    }
    system("pause");//按任意键继续
    system("cls");//清屏操作
    }
    int isexist(directory* abs, string name)//检测联系人是否存在【参数1—通讯录；参数2—对比数组中的姓名】
    {
    //检测联系人是否存在，如果存在，返回联系人所在数组中的具体位置，不存在返回-1
    for (int i = 0; i < abs->size; i++)//遍历数组中所有人的信息
    {
    if (abs->personArray[i].name == name)
    {
    return i;//如果存在，返回联系人所在数组中的具体位置
    }
    }
    return -1;//不存在，返回-1	
    }
    void deletecontacts(directory* abs)//删除所选联系人
    {
    cout << "请输入您要删除的用户" << endl;
    string name;
    cin >> name;
    int ret = isexist(abs, name);
    if (ret != -1)//若不等于-1，即查询到此人，进行删除操作
    {
    for (int i = ret; i < abs->size; i++)//删除某位数据，后续数据向前迁移
    {
    abs->personArray[i] = abs->personArray[i + 1];
    }
    abs->size--;//更新通讯录人数
    cout << "删除成功" << endl;
    }
    else
    {
    cout << "查无此人" << endl;
    }
    system("pause");//按任意键继续
    system("cls");//清屏操作
    }
    void checkcontacts(directory* abs)//查找所选联系人
    {
    cout << "请输入您要查找的用户" << endl;
    string name;
    cin >> name;
    int ret = isexist(abs, name);
    if (ret != -1)//若不等于-1，即查询到此人，进行显示其信息
    {
    cout << "姓名:" << abs->personArray[ret].name << "\t";
    cout << "性别:" << (abs->personArray[ret].sex == 1 ? "男" : "女") << "\t";
    cout << "年龄:" << abs->personArray[ret].age << "\t";
    cout << "电话号码:" << abs->personArray[ret].telephone << "\t";
    cout << "地址:" << abs->personArray[ret].address << endl;
    }
    else
    {
    cout << "查无此人" << endl;
    }
    system("pause");//按任意键继续
    system("cls");//清屏操作
    }
    void modifycontacts(directory* abs)//修改所选联系人
    {
    cout << "请输入您要查找的用户" << endl;
    string name;
    cin >> name;
    int ret = isexist(abs, name);
    if (ret != -1)//若不等于-1，即查询到此人，可以修改其信息
    {
    cout << "请重新输入姓名" << endl;//修改姓名
    string name;
    cin >> name;
    abs->personArray[ret].name = name;
    cout << "请重新输入性别(1为男生，2为女生)" << endl;//修改性别
    int sex = 0;
    while (true)
    {
    cin >> sex;
    if (sex == 1 or sex == 2)
    {
    abs->personArray[ret].sex = sex;
    break;
    }
    cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    }
    cout << "请重新输入年龄" << endl;//修改年龄
    int age;
    cin >> age;
    abs->personArray[ret].age = age;
    cout << "请重新输入电话号码" << endl;//修改电话号码
    string telephone;
    cin >> telephone;
    abs->personArray[ret].telephone = telephone;
    cout << "请重新输入住址" << endl;//修改住址
    string address;
    cin >> address;
    abs->personArray[ret].address = address;
    
    cout << "修改成功" << endl;
    }
    else
    {
    cout << "查无此人" << endl;
    }
    system("pause");//按任意键继续
    system("cls");//清屏操作
    }
    [//1.显示菜单界面](notion://1.xn--4krx35bn4k6yd4uq4q2a/)
    void showMenu()
    {
    cout << "***" << endl;
    cout << "1.添加联系人" << endl;
    cout << "2.显示联系人" << endl;
    cout << "3.删除联系人" << endl;
    cout << "4.查找联系人" << endl;
    cout << "5.修改联系人" << endl;
    cout << "6.清空联系人" << endl;
    cout << "0.退出通讯录" << endl;
    cout << "***" << endl;
    }
    int main()
    {
    directory abs;//创建通讯录结构体变量
    abs.size = 0;//初始化通讯录当前人员个数
    
    int select = 0;//创建用户选择变量
    
    while (true)//设置循环，当结果为0时，则退出通讯录；否则仍然在通讯录里循环
    {
    showMenu();//调用显示菜单界面
    cin >> select;//用户输入选择结果
    //用户选择分支架构
    switch (select)
    {
    case 1://1.添加联系人
    addcontacts(&abs);//调用添加联系人函数—利用地址传递修改实参【由于值传递无法修改实参，因此选用地址传递】
    break;
    case 2://2.显示联系人
    showcontacts(&abs);//调用显示联系人函数
    break;
    case 3://3.删除联系人
    deletecontacts(&abs);//调用删除联系人函数
    break;
    case 4://4.查找联系人
    checkcontacts(&abs);//调用查找联系人函数
    break;
    case 5://5.修改联系人
    modifycontacts(&abs);//调用修改联系人函数
    break;
    case 6://6.清空联系人
    break;
    default://0.退出通讯录
    cout << "欢迎下次使用" << endl;
    system("pause");
    return 0;
    break;
    }
    }
    
    system("pause");
    return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20211.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20212.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20213.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20214.png)
    
    - 封装修改联系人函数
    - 测试修改联系人
    
    ---
    
    <aside>
    🏆 代码应用——清空联系人
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    #define MAX 1000//设置最大人数为1000
    
    struct contacts//联系人结构体
    {
    	string name;//姓名
    	int sex;//性别(男生为1，女生为0)
    	int age;//年龄
    	string telephone;//电话号码
    	string address;//住址
    };
    struct directory//通讯录结构体
    {
    	struct contacts personArray[MAX];//通讯录现存联系人数组
    	int size;//通讯录现存人员个数
    };
    
    void addcontacts(directory* abs)//添加联系人函数
    {
    	//如果现存函数已达存取上限，则无法添加；如果现存函数未达到存取上限，可继续添加
    	if (abs->size == MAX)//如果现存函数已达存取上限，则无法添加
    	{
    		cout << "通讯录已满，无法添加！" << endl;
    		return;
    	}
    	else//如果现存函数未达到存取上限，可继续添加
    	{
    		//姓名
    		cout << "请输入姓名：" << endl;
    		string name;//姓名
    		cin >> name;
    		abs->personArray[abs->size].name = name;
    		//性别
    		cout << "请输入性别（1为男生，2为女生）" << endl;
    		int sex = 0;
    		while (true)//如果输入的是1或者2则退出循环，否则卡在死循环直到输对为止
    		{
    			cin >> sex;
    			if (sex == 1 or sex == 2)
    			{
    				abs->personArray[abs->size].sex = sex;
    				break;
    			}
    			cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    		}
    		//年龄
    		cout << "请输入年龄" << endl;
    		int age = 0;
    		cin >> age;
    		abs->personArray[abs->size].age = age;
    		//电话号码
    		cout << "请输入电话号码" << endl;
    		string telephone;
    		cin >> telephone;
    		abs->personArray[abs->size].telephone = telephone;
    		//地址
    		cout << "请输入住址" << endl;
    		string address;
    		cin >> address;
    		abs->personArray[abs->size].address = address;
    		//更新通讯录人数
    		abs->size++;
    		cout << "添加成功" << endl;
    		//清屏
    		system("pause");//请按任意键继续
    		system("cls");//清屏操作
    	}
    };
    void showcontacts(directory* abs)//显示所有联系人
    {
    	//判断通讯录人数是否为0，如果为0，提示记录为空；如果不为0，显示记录的联系人信息
    	if (abs->size == 0)//如果为0，提示记录为空；
    	{
    		cout << "当前记录为空" << endl;
    	}
    	else//如果不为0，采用遍历的方法—显示记录的联系人信息；
    	{
    		for (int i = 0; i < abs->size; i++)
    		{
    			cout << "姓名:" << abs->personArray[i].name << "\t";
    			cout << "性别:" << (abs->personArray[i].sex == 1 ? "男" : "女") << "\t";
    			cout << "年龄:" << abs->personArray[i].age << "\t";
    			cout << "电话号码:" << abs->personArray[i].telephone << "\t";
    			cout << "地址:" << abs->personArray[i].address << endl;
    		}
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    int isexist(directory* abs, string name)//检测联系人是否存在【参数1—通讯录；参数2—对比数组中的姓名】
    {
    	//检测联系人是否存在，如果存在，返回联系人所在数组中的具体位置，不存在返回-1
    	for (int i = 0; i < abs->size; i++)//遍历数组中所有人的信息
    	{
    		if (abs->personArray[i].name == name)
    		{
    			return i;//如果存在，返回联系人所在数组中的具体位置
    		}
    	}
    	return -1;//不存在，返回-1	
    }
    void deletecontacts(directory* abs)//删除所选联系人
    {
    	cout << "请输入您要删除的用户" << endl;
    	string name;
    	cin >> name;
    	int ret = isexist(abs, name);
    	if (ret != -1)//若不等于-1，即查询到此人，进行删除操作
    	{
    		for (int i = ret; i < abs->size; i++)//删除某位数据，后续数据向前迁移
    		{
    			abs->personArray[i] = abs->personArray[i + 1];
    		}
    		abs->size--;//更新通讯录人数
    		cout << "删除成功" << endl;
    	}
    	else
    	{
    		cout << "查无此人" << endl;
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    void checkcontacts(directory* abs)//查找所选联系人
    {
    	cout << "请输入您要查找的用户" << endl;
    	string name;
    	cin >> name;
    	int ret = isexist(abs, name);
    	if (ret != -1)//若不等于-1，即查询到此人，进行显示其信息
    	{
    		cout << "姓名:" << abs->personArray[ret].name << "\t";
    		cout << "性别:" << (abs->personArray[ret].sex == 1 ? "男" : "女") << "\t";
    		cout << "年龄:" << abs->personArray[ret].age << "\t";
    		cout << "电话号码:" << abs->personArray[ret].telephone << "\t";
    		cout << "地址:" << abs->personArray[ret].address << endl;
    	}
    	else
    	{
    		cout << "查无此人" << endl;
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    void modifycontacts(directory* abs)//修改所选联系人
    {
    	cout << "请输入您要查找的用户" << endl;
    	string name;
    	cin >> name;
    	int ret = isexist(abs, name);
    	if (ret != -1)//若不等于-1，即查询到此人，可以修改其信息
    	{
    		cout << "请重新输入姓名" << endl;//修改姓名
    		string name;
    		cin >> name;
    		abs->personArray[ret].name = name;
    		cout << "请重新输入性别(1为男生，2为女生)" << endl;//修改性别
    		int sex = 0;
    		while (true)
    		{
    			cin >> sex;
    			if (sex == 1 or sex == 2)
    			{
    				abs->personArray[ret].sex = sex;
    				break;
    			}
    			cout << "输入有误，请重新输入性别（1为男生，2为女生）" << endl;
    		}
    		cout << "请重新输入年龄" << endl;//修改年龄
    		int age;
    		cin >> age;
    		abs->personArray[ret].age = age;
    		cout << "请重新输入电话号码" << endl;//修改电话号码
    		string telephone;
    		cin >> telephone;
    		abs->personArray[ret].telephone = telephone;
    		cout << "请重新输入住址" << endl;//修改住址
    		string address;
    		cin >> address;
    		abs->personArray[ret].address = address;
    
    		cout << "修改成功" << endl;
    	}
    	else
    	{
    		cout << "查无此人" << endl;
    	}
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    void clean(directory* abs)
    {
    	abs->size = 0;//将当前记录联系人数量置为0，做逻辑清空操作
    	cout<< "通讯录已清空" << endl;
    	system("pause");//按任意键继续
    	system("cls");//清屏操作
    }
    //1.显示菜单界面
    void showMenu()
    {
    	cout << "*************************" << endl;
    	cout << "*****1.添加联系人*****" << endl;
    	cout << "*****2.显示联系人*****" << endl;
    	cout << "*****3.删除联系人*****" << endl;
    	cout << "*****4.查找联系人*****" << endl;
    	cout << "*****5.修改联系人*****" << endl;
    	cout << "*****6.清空联系人*****" << endl;
    	cout << "*****0.退出通讯录*****" << endl;
    	cout << "*************************" << endl;
    }
    int main()
    {
    	directory abs;//创建通讯录结构体变量
    	abs.size = 0;//初始化通讯录当前人员个数
    
    	int select = 0;//创建用户选择变量
    
    	while (true)//设置循环，当结果为0时，则退出通讯录；否则仍然在通讯录里循环
    	{
    		showMenu();//调用显示菜单界面
    		cin >> select;//用户输入选择结果
    		//用户选择分支架构
    		switch (select)
    		{
    		case 1://1.添加联系人
    			addcontacts(&abs);//调用添加联系人函数—利用地址传递修改实参【由于值传递无法修改实参，因此选用地址传递】
    			break;
    		case 2://2.显示联系人
    			showcontacts(&abs);//调用显示联系人函数
    			break;
    		case 3://3.删除联系人
    			deletecontacts(&abs);//调用删除联系人函数
    			break;
    		case 4://4.查找联系人
    			checkcontacts(&abs);//调用查找联系人函数
    			break;
    		case 5://5.修改联系人
    			modifycontacts(&abs);//调用修改联系人函数
    			break;
    		case 6://6.清空联系人
    			clean(&abs);
    			break;
    		default://0.退出通讯录
    			cout << "欢迎下次使用" << endl;
    			system("pause");
    			return 0;
    			break;
    		}
    	}
    
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20215.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20216.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20217.png)
    
    - 封装清空联系人函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20218.png)
        
    - 测试清空联系人
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20219.png)
        
    
    ---
    
- C++程序内存模型【代码区、全局区、栈区、堆区】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20220.png)
    
    <aside>
    🏆 代码应用——代码区【程序运行前】
    
    </aside>
    
    - 代码区【存放代码—共享、只读—操作系统管理】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20221.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——全局区【程序运行前】——【全局变量、静态变量、字符串、常量修饰的全局变量】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int g_a = 10;//定义全局变量
    int g_b = 10;
    int c_g_a = 10;//定义const修饰的全局变量
    int main()
    {		
    	//全局变量、静态变量、常量
    
    	//定义普通局部变量
    	int a = 10;
    	int b = 10;
    	cout <<"局部变量a的地址为：" << (int)&a << endl;
    	cout << "局部变量b的地址为：" << (int)&b << endl;
    	//全局区—全局变量、静态变量、常量
    	//全局变量
    	cout << "全局变量g_a的地址为：" << (int)&g_a << endl;
    	cout << "全局变量g_b的地址为：" << (int)&g_b << endl;
    	//精态变量—在普通变量前面加static即为静态变量
    	static int s_a = 10;
    	static int s_b = 10;
    	cout << "静态变量s_a的地址为：" << (int)&s_a << endl;
    	cout << "静态变量s_b的地址为：" << (int)&s_b << endl;
    	//常量—字符串常量、const修饰的常量
    	cout << "字符串地址为:" << (int)&"Hello World" << endl;
    
    	cout << "const修饰的全局常量地址为:" << (int)&c_g_a << endl;
    	const int c_l_a = 10;
    	cout << "const修饰的局部变量地址为:" << (int)&c_l_a << endl;
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20222.png)
    
    - 全局区【全局变量、静态常量—在程序结束后由操作系统释放】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20223.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20224.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20225.png)
    
    ---
    
    <aside>
    🏆 代码应用——栈区【程序运行后】
    
    </aside>
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20226.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20227.png)
    
    - 栈区【函数括号中的形参、局部变量——由编译器管理】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20228.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——堆区&new操作符【程序运行后】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int* func()//定义函数指针
    {
    int* p = new int(10);//在堆区开辟一个内存空间，存放10，然后将new返回【数据地址】传给p进行接收
    //其中指针p地址编号存放在栈区，而int整形变量10存放在堆区
    *return p;//返回指针地址
    }	
    
    void test01()
    {
    int ** p = func();//在堆区开辟数据，用指针进行接收
    cout << *p << endl;//输出该执政地址的内容
    delete p;//利用delete【堆区数据释放】
    //cout << *p << endl;//内存已被释放，再次访问就是非法操作
    }
    void test02()
    {
    int*arr=new int[10];//在堆区存放数组
    for (int i = 0;i < 10; i++)
    {
    arr[i] = i + 100;//给10个元素赋值，赋值为100~109
    }
    for (int i = 0;i < 10; i++)
    {
    cout << arr[i] << endl;//输出数据
    }
    
    delete[]arr;//利用delete【堆区存放数组释放】
    }
    int main()
    {
    test01();
    test02();
    system("pause");
    return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20229.png)
    
    - 堆区
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20230.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20231.png)
        
        栈区存放堆区数据的地址、用指针记录其地址
        
    - new操作符
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20232.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20233.png)
        
    
    ---
    
- C++引用【引用语法、引用注意事项、引用传递、引用作函数返回值、引用本质、常量引用】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——引用基本语法【给变量取别名】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int a = 10;//定义变量
    	int &b = a;//引用—数据类型&别名=原名
    	b = 20;//a,b用统一个内存，b修改则a数据也修改
    	cout << a << endl;
    	cout << b << endl;
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20234.png)
    
    - 引用基本语法【给变量起别名】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20235.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20236.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——引用注意事项【引用必须有指代对象，引用指代后不能i修改】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    int main()
    {
    	int& b;//------------错误的，引用必须初始化【即指定对象】
    	int a = 10;//定义变量
    	int& b = a;//引用—数据类型&别名=原名
    	int c = 20;
    	int& b = c;//--------错误的，引用在初始化后，不可以更改【由于b关联对象a，无法重复关联c】
    	
    	cout << a << endl;
    	cout << b << endl;
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    - 引用注意事项
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20237.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20238.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——引用做函数【引用传递——直接操作原数据】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //3.引用传递
    void mySwap03(int& a, int& b)
    {
    	int temp = a;
    	a = b;
    	b = temp;
    	cout << "引用传递交换函数中的形参a=" << a << endl;//形参发生改变
    	cout << "引用传递交换函数中的形参b=" << b << endl;
    }
    //1.值传递
    void mySwap01(int a, int b)
    {
    	int temp = a;
    	a = b;
    	b = temp;
    	cout << "值传递交换函数中的a=" << a << endl;//形参发生改变
    	cout << "值传递交换函数中的b=" << b << endl;
    }
    //2.地址传递
    void mySwap02(int* a, int* b)
    {
    	int temp = *a;
    	*a = *b;
    	*b = temp;
    	cout << "地址传递交换函数中的形参a=" << *a << endl;//形参发生改变
    	cout << "地址传递交换函数中的形参b=" << *b << endl;
    }
    int main()
    {
    	int a = 10;
    	int b = 20;
    	
    	mySwap03(a, b);//引用传递—形参改变同时修改实参
    	cout << "a=" << a << endl;
    	cout << "b=" << b << endl;
    	mySwap01(a, b);//值传递—形参改变不会修改实参
    	cout << "a=" << a << endl;
    	cout << "b=" << b << endl;
    	mySwap02(&a, &b);//地址传递—形参改变同时修改实参
    	cout << "a=" << a << endl;
    	cout << "b=" << b << endl;
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20239.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20240.png)
    
    - 引用传递
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20241.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20242.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20243.png)
    
    ---
    
    <aside>
    🏆 代码应用——引用做函数返回值
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    //引用做函数返回值
    //1.不要返回局部变量的引用
    //2.引用作函数的返回值
    int&test01()
    {
    	int a = 10;//局部变量—栈区【由编译器自动释放，因此不能返回局部变量的地址】
    	return a;
    }
    int& test02()//返回静态变量引用
    {
    	static int a = 10;//静态变量—全局区【数据在程序结束后系统释放】
    	return a;
    }
    int main()
    {
    	int& ref = test01();//【相当于ref与a是是同一个】
    	cout << "ref=" << ref << endl;//第一次正确是由于编译器做了保留
    	cout << "ref=" << ref << endl;//第二次就乱码了
    
    	int& ref2 = test02();//如果函数做左值，必须返回引用【相当于ref与静态变量是同一个】
    	cout << "ref2=" << ref2 << endl;
    	cout << "ref2=" << ref2 << endl;
    	test02() = 1000;
    	cout << "ref2=" << ref2 << endl;
    	cout << "ref2=" << ref2 << endl;
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20244.png)
    
    - 引用做函数返回值
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20245.png)
        
        - 不要返回局部变量引用
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20246.png)
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20247.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——引用的本质【指针常量】
    
    </aside>
    
    - 引用的本质【指针常量】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20248.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20249.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20250.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——常量引用【修饰形参、防止误操作】
    
    </aside>
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20251.png)
    
    - 常量引用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20252.png)
        
        - 加上const后变为只读，不可修改
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20253.png)
            
    
    ---
    
- C++函数高级【默认参数、占位参数、函数重载、函数重载注意事项】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——函数默认参数
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //函数参数自传入【func传入参数时间，少一个都会抱错】
    int func(int a, int b,int c)
    {
    	return a + b + c;
    }
    //函数默认值【优先接受传入的参数，再之后接受默认参数】
    //语法：返回值类型 函数名（形参=默认值）{函数体内部代码}
    //注意事项1.如果某个位置已经有默认参数，那么之后的参数都需要有默认参数【b有默认参数，则c不需要要设置默认参数】
    int func2(int a , int b = 20, int c = 30)
    {
    	return a + b + c;
    }
    //2.如果函数声明有默认参数，函数实现就不能有默认参数[声明和实现只能有一个写默认参数]
    int func3(int a = 10,int b = 20);//函数申明已经设置了默认参数
    
    int func3(int a,int b)//函数实现——无需再次设置默认参数
    {
    	return a + b;
    }
    int main()
    {
    	cout << func(10, 20, 30) << endl;
    	cout << func2(10, 30) << endl;
    	cout << func3() << endl;
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20254.png)
    
    - 函数默认参数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20255.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20256.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数占位参数
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    //占位参数—返回值类型 函数名(数据类型){}
    void func(int , int b)//第二个参数为占位参数
    {
    	cout << "这是一个函数调用" << endl;
    }
    //占位参数 还可以有默认参数
    void func2(int, int=10)
    {
    	cout << "这是另一个函数调用" << endl;
    }
    int main()
    {
    	func(10,10);//占位数据必须要有相应的数据类型的数据传入
    	func2(10);
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20257.png)
    
    - 函数占位参数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20258.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数重载
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    //函数重载—可以让函数重名，提高函数的复用性
    //函数重载的满足条件—1.同一个作用域下/2.函数名称相同/3.函数参数类型不同，或者个数不同，或者顺序不同
    void func()//不在main内部的均为全局作用域内
    {
    	cout << "func( )调用" << endl;
     }
    void func(int a)//全局作用域内、函数名称相同、第1个函数不带参数，第2个函数带1个参数【个数不同】
    {
    	cout << "func（int）调用" << endl;
    }
    void func(double a)//全局作用域内、函数名称相同，第2个函数类型为int，第3个函数类型为double【类不同】
    {
    	cout << "func（double）调用" << endl;
    }
    void func(int a, double b)//全局作用域内、函数名称相同、第4个函数为（int，double）,第5个函数为(double,int)【顺序不同】
    {
    	cout << "func（int,double）调用" << endl;
    }
    void func(double a, int b)
    {
    	cout << "func（double,int）调用" << endl;
    }
    //注意事项—函数的返回值不可以作为函数重载的条件
    int main()
    {
    	func();//调用第1个函数
    	func(10);//调用第2个函数
    	func(3.14);//调用第3个函数
    	func(9.99, 20);//调用第5个函数
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20259.png)
    
    - 函数重载
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20260.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数重载注意事项
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //注意事项—1.引用作为重载条件，常量和变量的注意要求
    void func(int&a)//int &a=10【不合法，引用必须取栈区或堆区数据，10放在常量区】
    {
    	cout << "fun(int &a)调用" << endl;
    }
    void func(const int& a)//const int&a=10【合法操作】
    {
    	cout << "func(const int&a)调用" << endl;
    }
    //2.函数重载与默认参数联用时,编译器无法识别
    void func2(int a,int b=10)
    {
    	cout << "func (int a ,int b)调用" << endl;
    }
    void func2(int a)
    {
    	cout<< "func（int）调用" << endl;
    }
    int main()
    {
    	int a = 10;
    	func(a);//调用第1个函数
    	func(10);//调用第2个函数
    	/*func2(10);*/ //调用不明确，即可以调用第3个，也可以调用第4个
    	system("pause");
    	return 0;
    }
    
    ```
    
    - 函数重载注意事项
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20261.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20262.png)
        
    
    ---
    
- C++类&对象——封装【创建类&赋值、创建类&赋值案例（设计学生类）、类访问权限、结构体与类区别、私有权限控制读写、私有权限控制读写案例（立方体、点圆关系）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——封装：类语法【权限、属性、行为、创建具体对象、给对象赋值】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    //定义Π常量
    const double PAI = 3.14;
    //class代表一个类，类 类名称[]
    class Circle
    {
    	//访问权限[设计访问权限]
    public:
    	//属性——定义半径变量[设计变量]
    	int m_r;
    	//行为—获取圆的周长[函数获取计算结果]
    	double calculateZC()
    	{
    		return 2 * PAI * m_r;
    	}
    };
    int main()
    {
    	//通过圆类—创建具体的圆（对象）【实例化,创建一个对象】
    	Circle c1;
    
    	//给圆对象的属性进行赋值【给该对象的属性赋值】
    	c1.m_r = 10;
    	
    	cout << "圆的周长为:" << c1.calculateZC() << endl; 
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20263.png)
    
    - 封装的意义
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20264.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20265.png)
    
    ---
    
    <aside>
    🏆 代码应用——封装：类案例【设计学生类】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    class student
    {
    	//访问权限
    public:
    	//属性—定义变量
    	string name;
    	string id;
    	//行为——获取学生姓名和学号
    	void showstudent()
    	{
    		cout << "姓名:" <<name<<"\t" << "学号:" << id << endl;
    	}
    };
    int main()
    {
    	//创建具体的学生对象
    	student s1;
    
    	//给对象进行赋值
    	s1.name = "张三";
    	s1.id = "164416110";
    
    	//显示学生信息
    	s1.showstudent();
    	system("pause");
    	return 0;
    }
    
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    class student
    {
    	//访问权限
    public:
    	//属性—定义变量
    	string s_name;
    	string s_id;
    	//行为——获取学生姓名和学号
    	void showstudent()
    	{
    		cout << "姓名:" <<s_name<<"\t" << "学号:" << s_id << endl;
    	}
    	//给对象赋值
    	void set(string name, string id)
    	{
    		s_name = name;
    		s_id = id;
    	}
    
    };
    int main()
    {
    	//创建具体的学生对象
    	student s1;
    	student s2;
    	//给函数传输值
    	s1.set("张三", "12");
    	s2.set("李四", "13");
    
    	//显示学生信息
    	s1.showstudent();
    	s2.showstudent();
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20266.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20267.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20268.png)
    
    ---
    
    <aside>
    🏆 代码应用——封装：类访问权限【公共权限、保护权限、私有权限】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    //类的访问权限
    class person
    {
    	//公共权限public【类内、类外均可以访问】
    public:
    	string m_name;
    	//保护权限protected【类内可以访问、类外不可以访问、子项可以访问父项内容】
    protected:
    	string m_car;
    	//私有权限private【类内可以访问、类外不可以访问、子项不可以访问父项内容】
    private:
    	int m_password;
    
    public:
    	void func()
    	{
    		m_name = "张三";
    		m_car = "拖拉机";
    		m_password = 12345;
    	}
    };
    int main()
    {
    	//实例化具体对象
    	person s1;
    	//
    	s1.m_name = "李四";
    	//s1.m_car= "奔驰";//保护权限内容，在类外无法访问
    	//s1.m_password = 11111;//私有权限内容，在类外无法访问
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20269.png)
    
    - 类的权限
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20270.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——封装：结构体&类区别【权限不同】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class s1
    {
    	int m_a;//默认权限—私有
    };
    struct s2
    {
    	int m_a;//默认权限—公有
    };
    int main()
    {
    	s1 c1;
    	//c1.m_a = 100;//class类的默认权限为private,因此无法在类外进行访问
    	s2 c2;
    	c2.m_a = 100;//stuct结构体的默认权限为public,因此在类内和类外均可以访问
    	system("pause");
    	return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20271.png)
    
    - 结构体&类区别
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20272.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——封装：私有权限控制读写权限【将变量设置在私有权限，将功能设置在公共权限】
    
    </aside>
    
    ```cpp
    //在私有权限下控制读写权限
    #include<iostream>
    using namespace std;
    #include<string>
    //私有属性—对其中属性进行公有化操作
    class person
    {
    public:
    	//姓名设计函数
    	void setname(string name)//写入名字
    	{
    		m_name= name;
    	}
    	string getname()//取名字
    	{
    		return m_name;
    	}
    	//年龄设计函数
    	int getage()//取年龄
    	{
    		
    		return m_age;
    	}
    	//偶像设计函数
    	void setidol(string idol)//写入偶像
    	{
    		m_idol = idol;
    	}
    private:
    	//属性
    	string m_name;//设计需求—可读可写
    	int m_age=18;//设计需求—只读不可写
    	string m_idol;//设计需求—只写不可读
    };
    int main()
    {
    	//实例化具体对象
    	person s1;
    	//姓名设计实现
    	s1.setname("张三");
    	cout << "姓名：" << s1.getname()<< endl;	
    	//年龄设计实现
    	cout << "年龄:" << s1.getage()<< endl;
    	//偶像设计实现
    	s1.setidol("one ok rock");
    
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    //在上述不变的情况下，对年龄进行限制【只允许输入0~150的值，否则输出年龄输入有误】
    #include<iostream>
    using namespace std;
    #include<string>
    //私有属性—对其中属性进行公有化操作【控制读写权限】
    class person
    {
    public:
    	//姓名设计函数
    	void setname(string name)//写入名字
    	{
    		m_name= name;
    	}
    	string getname()//取名字
    	{
    		return m_name;
    	}
    	//年龄设计函数
    	
    	void setage(int age)
    	{
    		if (age < 0 || age>150)
    		{
    			cout << "年龄输入有误，赋值失败" << endl;
    			return;
    		}
    		m_age = age;
    	}
    	int getage()
    	{
    
    		return m_age;
    	}
    	//偶像设计函数
    	void setidol(string idol)
    	{
    		m_idol = idol;
    	}
    private:
    	//属性
    	string m_name;//设计需求—可读可写
    	int m_age;//设计需求—可读可限制范围写
    	string m_idol;//设计需求—只写不可读
    };
    int main()
    {
    	//实例化具体对象
    	person s1;
    	//姓名设计实现
    	s1.setname("张三");
    	cout << "姓名：" << s1.getname()<< endl;	
    	//年龄设计实现
    	s1.setage(130);
    	cout << "年龄:" << s1.getage()<< endl;
    	//偶像设计实现
    	s1.setidol("one ok rock");
    	
    	system("pause");
    	return 0;
    }
    
    ```
    
    - 成员属性设置为私有
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20273.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20274.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20275.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20276.png)
    
    ---
    
    <aside>
    🏆 代码应用——私有设置读写案例【设计立方体】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    class cubic
    {
    	//权限
    public:
    	//行为-读写长宽高、获取立方体周长、获取立方体体积
    	void setl(int l)//写入长宽高
    	{
    		ml = l;
    	}
    	int getl()
    	{
    		return ml;
    	}
    	void setb(int b)
    	{
    		mb = b;
    	}
    	int getb()
    	{
    		return mb;
    	}
    	void seth(int h)
    	{
    		mh = h;
    	}
    	int geth()
    	{
    		return mh;
    	}
    	int calcluateS()//获取立方体表面积
    	{
    		return 2 * (ml * mb + ml * mh + mb * mh);
    	}
    	int calcluateV()//获取立方体体积
    	{
    		return ml * mb * mh;
    	}
    	bool issame_byclass(cubic &c)
    	{
    		if (ml=c.getl() && mb == c.getb() && mh == c.geth())
    		{
    			return true;
    		}
    		return false;
    	}
    	
    private:
    	//属性—长宽高变量
    	int ml;
    	int	mb;
    	int mh;
    };
    
    //利用全局函数判断两立方体是否相等
    bool issame (cubic &s1,cubic &s2)
    {
    	if (s1.calcluateS() == s2.calcluateS() && s1.calcluateV() == s2.calcluateV())
    	{
    		return true;
    	}
    	return false;
    }
    
    int main()
    {
    	cubic s1;//创建具体的立体体实例
    	s1.setl(10);
    	s1.seth(10);
    	s1.setb(10);
    	cout << "表面积为:" << s1.calcluateS() <<"\t" << "体积为:" << s1.calcluateV() << endl;
    	cubic s2;
    	s2.setl(8);
    	s2.seth(8);
    	s2.setb(8);
    	//全局函数判断结果
    	bool ret = issame(s1,s2);
    	if (ret)
    	{
    		cout << "全局函数判断—这两个立方体相等" << endl;
    	}
    	else
    	{
    		cout << "全局函数判断—这两个立方体不想等" << endl;
    	}
    	//成员函数判断
    	ret = s1.issame_byclass(s2);
    	if (ret)
    	{
    		cout << "成员函数判断—这两个立方体相等" << endl;
    	}
    	else
    	{
    		cout << "成员函数判断—这两个立方体不想等" << endl;
    	}
    
    	system("pause");
    	return 0;
    }
    
    ```
    
    - 私有设置读写案例【设计立方体】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20277.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20278.png)
    
    ---
    
- C++类和对象——对象特性【构造函数&析构函数、构造函数2种分类&3种调用、拷贝构造函数、构造函数调用原则、深拷贝&浅拷贝、初始化列表、类对象作为类成员、静态成员变量、静态成员函数、成员变量&成员函数分开储存、this指针、空指针访问成员函数、const修饰长函数、const修饰常对象】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——对象特性：对象初始化&清理【构造函数、析构函数】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
    public:
    //构造函数——1.构造函数没有返回值也不用写void；2.函数名称与类名称相同；
    //3.构造函数可以有参数，因此可以发生重载；4.程序在调用对象时会自动调用构造，无须手动调用且只会调用一次
    	person()
    	{
    		cout << "构造函数调用" << endl;
    	}
    //析构函数——1.析构函数没有返回值也不用写void；2.函数名称与类名称相同，在名称前加上~；
    //3.构造函数不可以有参数，因此不可以发生重载；4.对象在销毁前会自动调用析构函数，无须手动调用且只会调用一次
    	~person()
    	{
    		cout << "析构函数调用" << endl;
    	}
    };
    //注意事项—构造和析构都必须有的实现，如果自己不提供代码，编译器会自动提供一个空实现的构造和析构【上方两个为构造和析构的实现】
    void test01()
    {
    	person p;//存放在栈区，test01执行完成后，会自动释放这个对象
    }
    
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }turn 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20279.png)
    
    - 构造函数、析构函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20280.png)
        
    - 构造函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20281.png)
        
    - 析构函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20282.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：构造函数的分类&调用
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
    public:
    //构造函数
    	//按参数分类—无参构造和有参构造
    	person()//无参构造
    	{
    		cout << "person无参构造函数调用" << endl;
    	}
    	person(int a)//有参构造
    	{
    		age = a;
    		cout << "person有参构1造函数调用" << endl;
    	}
    	//拷贝构造【上方均为普通构造】
    	person(const person &p)//const 限定后方的本体数据不被修改；且用引用拷贝一份原始数据
    	{
    		cout << "person拷贝构造函数调用" << endl;
    		//将原始数据的参数属性拷贝到
    		age = p.age;
    	}
    //析构函数
    	~person()
    	{
    		cout << "person析构函数调用" << endl;
    	}
    	int age;
    };
    //注意事项—构造和析构都必须有的实现，如果自己不提供代码，编译器会自动提供一个空实现的构造和析构【上方两个为构造和析构的实现】
    void test01()
    {
    	//3种调用方式—1.括号法 2.显示法 3.隐式转换法
    	//1.括号法
    	person p1;//无参函数调用【注意不要加（），程序会被识别为函数的声明】
    	person p2(10);//有参函数调用
    	person p3( p2);//拷贝p2数据—拷贝构造调用
    	cout << "p2年龄为:" << p2.age << endl;
    	cout << "p3年龄为:" << p3.age << endl;//有于拷贝构造，p3拷贝了p2的数据
    	//2.显示法
    	person p1;//无参函数调用
    	person p2 = person(10);//有参函数调用【右侧为匿名对象；当系统执行结束后，系统会立即回收匿名对象】
    	person p3 = person(p2);//拷贝函数调用
    	//person(10);//注意事项1—左侧为匿名对象 特点：当前行执行结束后，系统会立即回收匿名对象
    	// cout<<"aaaa"<<endl;
    	 
    	//注意事项2—不利用拷贝构造函数 初始化匿名对象
    	//person(p3);person(p3)其实相当于person p3【上方有person p3，因此会发生重定义】
    	//3.隐式转换法
    	person p1;//无参函数调用
    	person p4 = 10;//有参函数调用,相当于写了person p4=person(10);
    	person p5 = p4;//拷贝函数调用
    }
    
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 构造函数的分类&调用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20283.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20284.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20285.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20286.png)
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：拷贝构造函数调用时机【已经创建好的初始化新的、值传递、值返回局部对象】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
    public:
    	person()
    	{
    		cout << "person无参（默认）构造函数调用" << endl;
    	}
    	person(int age)
    	{
    		mage = age;
    		cout << "person有参构造函数调用" << endl;
    	}
    	person(const person& p)
    	{
    		mage = p.mage;
    		cout << "person拷贝构造函数调用" << endl;
    	}
    	~person()
    	{
    		cout << "person析构函数调用" << endl;
    	}
    	int mage;
    };
    
    //拷贝构造函数调用时机
    //1.使用1个已经创建完毕的对象来初始化一个新对象
    void test01()
    {
    	person p1(20);//有参函数调用
    	person p2(p1);//拷贝构造函数调用
    	cout << p2.mage << endl;
    }
    //2.值传递方式给函数参数传值【值传递为拷贝构造】
    void dowork(person p)//将下方的p值传递的方式传入该函数
    {
    }
    
    void test02()
    {
    	person p;//无参（默认）函数调用
    	dowork(p);//将p以值传递方式传给dowork【值传递相当于拷贝副本】
    }
    
    //3.值方式返回局部对象
    person dowork2()
    {
    	person p1;//无参函数调用
    	return p1;
    }
    void test03()
    {
    	person p2 = dowork2();
    }
    
    int main()
    {
    	test01();
    	test02();
    	test03();
    	system("pause");
    	return 0;
    }
    ```
    
    - 拷贝构造函数调用时机
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20287.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20288.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20289.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20290.png)
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：构造函数调用规则【默认构造函数、默认析构函数、默认拷贝构造函数】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    //构造函数的调用规则
    // 1.创建1个类，C++编译器会给每个类添加至少3个函数
    // 默认构造（空实现）；析构函数（空实现）；拷贝构造函数（值拷贝）
    
    class person
    {
    public:
    	person()
    	{
    		cout << "person无参构造函数调用" << endl;
    	}
    	person(int age)
    	{
    
    		cout << "person有参构造函数调用" << endl;
    		mage = age;
    	}
    	person(const person& p)
    	{
    		cout << "person拷贝构造函数调用" << endl;
    		mage = p.mage;
    	}
    	~person()
    	{
    		cout << "person析构函数调用" << endl;
    	}
    	int mage;
    };
    void test01()
    {
    	person p;
    	p.mage = 18; 
    	person p2(p);
    	cout << "p2的年龄为:" << p2.mage << endl;
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 构造函数调用规则
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20291.png)
        
    
    ```cpp
    #include<iostream>
    using namespace std;
    //构造函数的调用规则
    // 1.创建1个类，C++编译器会给每个类添加至少3个函数
    // 默认构造（空实现）；析构函数（空实现）；拷贝构造函数（值拷贝）
    
    class person
    {
    public:
    	person()
    	{
    		cout << "person无参构造函数调用" << endl;
    	}
    	person(int age)
    	{
    
    		cout << "person有参构造函数调用" << endl;
    		mage = age;
    	}
    	person(const person& p)
    	{
    		cout << "person拷贝构造函数调用" << endl;
    		mage = p.mage;
    	}
    	~person()
    	{
    		cout << "person析构函数调用" << endl;
    	}
    	int mage;
    };
    
    void test02()
    {
    	person p(28);
    	person p2(p);
    	cout << "p2的年龄为:" << p2.mage << endl;
    }
    int main()
    {
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    ---
    
    1. 创建1个类，编译器会给每个类添加至少3个函数——默认构造（空实现）；析构函数（空实现）；拷贝构造函数（值拷贝）【注释掉后拷贝构造函数后，仍然会进行值拷贝操作】
    
    - 默认情况下
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20292.png)
        
    
    - 注释掉自定义后的拷贝构造后
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20293.png)
        
    
    ---
    
    1. 用户自定义有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造
    
    将默认构造先注释掉后，编译器不再提供默认构造【若用户进行默认构造调用会报错】
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20294.png)
    
    ---
    
    - 用户自定义有参构造函数下仍然提供有参、拷贝
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20295.png)
        
    
    ---
    
    将默认构造、有参构造均注释掉后，编译器不太提供默认、有参构造【若用户进默认、有参调用就会报错】
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20296.png)
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：深拷贝&浅拷贝
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    //深拷贝&浅拷贝
    class person
    {
    public:
        person()
        {
            cout << "默认构造函数调用" << endl;
        }
        person(int age,int height)
        {
            mage = age;
            mheight = new int(height);//new返回的是指针，用指针接收堆区的数据【需要人工释放】
            cout << "有参构造函数调用" << endl;
        }
        person(const person& p)
        {
            mage = p.mage;
            mheight = new int(*p.mheight);//【深拷贝操作】*解引用，取出地址中的数据
            cout << "拷贝构造函数调用" << endl;
        }
        ~person()
        {
            if (mheight != NULL)
            {
                delete mheight;
                mheight = NULL;
            }
            cout << "析构函数调用" << endl;
        }
        int mage;//年龄
        int* mheight;//身高【*是采用指针，将身高数据开辟到堆区】
    };
    void test01()
    {
        person p1(18,160);
        cout << "p1的年龄为" << p1.mage << "p1的身高为"<<*p1.mheight<<endl;//*解引用，取出地址中的数据
        person p2(p1);
        cout << "p1的年龄为" << p2.mage << "p2的身高为" <<*p2.mheight << endl;//*解引用，取出地址中的数据
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 深拷贝、浅拷贝
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20297.png)
        
        - 浅拷贝【堆区数据重复释放】
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20298.png)
            
            数据遵循先进后出原则，故而p2优先释放了堆区数据，而后p1再次释放了该堆区数据【发生了报错】，浅拷贝造成了堆区数据重复释放
            
        - 深拷贝【在堆区开辟一个新的地址，使得p1&p2释放各自的堆区数据】
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20299.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：初始化列表
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
    public:
    	////传统初始化操作
    	//person(int a, int b, int c)
    	//{
    	//	ma = a;
    	//	mb = b;
    	//	mc = c;
    	//}
    	//初始化列表实现初始化属性
    	person(int a,int b,int c) :ma(a), mb(b), mc(c)
    	{
    	}
    	int ma;
    	int mb;
    	int mc;
    };
    void test01()//传动初始化
    {
    	person p(10, 20, 30);
    	cout << "ma值为:" << p.ma << " mb值为: " << p.mb << " mc值为: " << p.mc<<endl;
    }
    void test02()//采用初始化列表实现初始化属性
    {	
    	person p(30,20,10);
    	cout << "ma值为:" << p.ma << " mb值为: " << p.mb << " mc值为: " << p.mc << endl;
    }
    int main()
    {
    	/*test01();*/  //传统初始操作
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    - 初始化列表
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20300.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20301.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：类对象作为类成员
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    class phone//手机的类
    {
    public:
    	phone(string brand)
    	{
    		mbrand = brand;
    		cout << "phone函数调用" << endl;
    	}
    	~phone()
    	{
    		cout << "phone析构函数调用" << endl;
    	}
    	string mbrand;
    };
    
    class person//人的类
    { 
    public:
    	person(string name, string brand) :mname(name), mphone(brand)//初始化列表
    	{
    		cout << "person函数调用" << endl;
    	}
    	~person()
    	{
    		cout << "person析构函数调用" << endl;
    	}
    	string mname;//姓名
    	phone mphone;//电话
    };
    //当其他类对象作为本类成员时，构造时先构造其他类对象，再构造本类
    //析构函数时，先本类对象，再析构其他类对象【与构造顺序相反】
    void test01()
    {
    	person p("小王", "P");
    	cout << p.mname << "拿着" << p.mphone.mbrand << endl;
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20302.png)
    
    - 类对象作为类成员
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20303.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20304.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——类和对象：静态成员变量
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    //静态成员变量——所有对象都共享一份数据；且编译阶段就分配内存；需要类内声明，类外初始化操作
    class person
    {
    public:
    	static int ma;//类内申明【加上static后变为静态成员变量】
    
    	//静态成员变量也有访问权限【公有权限类外可以访问，私有权限类外无法访问】
    private:
    	static int mb;//类内声明
    };
    void test01()
    {
    	person p;
    	cout << p.ma << endl;
    	person p2;
    	p2.ma = 300;//由于ma为共享数据，因此p2.ma修改值为300后，p,ma输出为300
    	cout << p.ma << endl;
    }
    void test02()
    {
    	//静态成员变量有两种访问方式
    	//1.通过对象进行访问
    	person p;
    	cout << p.ma << endl;
    	//2.通过类名进行访问
    	cout << person::ma << endl;
    	//cout << person::mb << endl;//私有权限，类外无法访问
    }
    
    int person::ma = 200;//类外初始化操作
    int person::mb = 500;
    int main()
    {
    	test01();
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    - 静态成员
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20305.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20306.png)
        
        - test01
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20307.png)
            
        - 静态成员变量两种访问方式
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20308.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——类和对象：静态成员函数
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    //静态成员函数——所有对象同一个函数；静态成员函数只能访问静态成员变量
    
    class person
    {
    public:
    	static void func()//加上static后变为静态成员函数
    	{
    		ma = 100;//静态成员函数可以访问静态成员变量
    	/*	mb = 20;*///静态成员函数不可以访问非静态成员变量【非共享数据—无法区分到底是调用哪个对象的ma】
    		cout << "静态成员函数调用" << endl;
    	}
    	static int ma;//定义静态成员变量【类内声明】
    	int mb;//定义非静态成员变量
    
    private:
    	//静态成员函数也有访问权限
    	static void func2()
    	{
    		cout << "静态成员变量2调用" << endl;
    	}
    };
    void test01()
    {
    	//访问静态成员函数两种访问方式
    	//1.通过对象访问
    	person p;
    	p.func();
    	//2.通过类访问
    	person::func();
    	/*person::func2();*///私有权限，类外无法访问
    }
    int person::ma = 100;//类外初始化操作
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20309.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20310.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20311.png)
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：成员变量和成员函数分开储存
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    class person
    {
    };
    
    class person1
    {
    	int ma;//定义非静态成员变量【非静态成员变量——属于类的对象上】
    	static int mb;//定义静态成员变量【静态成员变量——不属于类的对象上】
    	void func() {}//定义非静态成员函数【由于成员函数和成员变量是分开存储的——不属于类的对象上】
    	static void func2() {}//定义静态成员函数【由于成员函数和成员变量是分开存储的——不属于类的对象上】
    };
    
    void test01()
    {
    	person p;//person类为空时，空对象占用内存空间为1个字节
    	cout << "person p所占有的内存空间" << sizeof(p) << endl;
    }
    void test02()
    {
    	person1 p;//person类含有非静态成员变量，占用内存空间为4个字节【int占有4个字节】
    	cout << "person p所占有的内存空间" << sizeof(p) << endl;
    }
    int person1::mb = 10;//静态成员变量类外初始化操作
    int main()
    {
    	test01();
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    - 成员变量和成员函数分开储存
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20312.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20313.png)
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：this指针
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    //this 指针用途—1.解决名称冲突 ；2.返回对象本事用*this
    class person
    {
    public:
    	person(int age)
    	{
    		//1.解决名称冲突
    		/*age = age;*///【这样会产生名称冲突】
    		this->age = age;//this指针指向被调用成员函数所属的对象【此时p1在调用person类，则此时this指向p1】
    	}
    	person & personaddage(person& p)//由于返回对象本体，因此需要person &接收
    	{
    		this->age += p.age;
    		return *this;//this指向p2指针，而*this指向就是p2这个对象的本体
    	}
    	int age;
    };
    
    void test01()
    {
    	person p1(18);
    	cout << "p1的年龄为:" << p1.age << endl;
    }
    void test02()
    {
    	person p1(10);
    	person p2(10);
    	p2.personaddage(p1).personaddage(p1).personaddage(p1);//需要返回对象本体才能实现该操作【链式编程思想】
    	cout << "p2的年龄为：" << p2.age << endl;
    }
    int main()
    {
    	test01();
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20314.png)
    
    - this指针
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20315.png)
        
        ---
        
        - 引用传递返回——返回对象本体
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20316.png)
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20317.png)
            
        - 值传递返回——返回对象拷贝体
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20318.png)
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20319.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：空指针访问成员函数
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
    public:
        void showclassname()
        {
            cout << "这是person class" << endl;
        }
    
        void showpersonage()
        {
    
            //cout << "age=" << mage << endl;//此时mage为this.mage，而此使this指向空指针，更无法访问mage属性
            cout << "age=" << mage << endl;
        }
    
        int mage;
    };
    
    void test01()
    {
        person* p = NULL; // 空指针
    
        if (p != NULL) // 检查指针是否为空，若指针非空，则进行输出
        {
            p->showclassname();
            p->showpersonage();
        }
        else//若指针为空，对空指针进行保护性输出
        {
            cout << "p is NULL, cannot call member functions." << endl;//
        }
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 空指针访问成员函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20320.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20321.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：const修饰常函数
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
    public:
        void showperson()const
        {
            ma = 100;//ma为this.ma【this指针本质为指针常量，只可以更改指针指向，而无法更改指针值】
            mb = 200;
        }
        int ma;
        //void()const相当于const person const *this//const修饰this指针，因而即无法修改指针指向，又无法修改指针指向的值】
         mutable int mb;//mutable使该变量成为特殊变量，即使在常函数中也可以修改这个值
    };
    
    void test01()
    {
        person p;
        p.showperson();
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - const修饰常函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20322.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——对象特性：const修饰常对象
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
    public:
        void showperson()const
        {
            ma = 100;//ma为this.ma【this指针本身为指针常量，只可以更改指针指向，而无法更改指针值】
            //void()const相当于const person const *this//const修饰this指针，因而即无法修改指针指向，又无法修改指针指向的值】
            mb = 200;
        }
        int ma;
        mutable int mb;//mutable使该变量成为特殊变量，即使在常函数中也可以修改这个值
        void func()
        {
        }
    };
    
    void test02()
    {
       const person p;//加上const后，变为常对象
       p.ma = 100;//无法修改常对象普通变量
       p.mb= 300;//mutable使该变量成为特殊变量，即使在常对象中也可以修改这个值
       p.showperson();
       p.func();//常对象无法修饰普通成员函数（因为普通成员函数可以修改属性），常对象只能调用常函数；
    }
    
    int main()
    {
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - const修饰常对象
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20323.png)
    
    ---
    
- C++类和对象——友元【全局函数作友元、类作友元、成员函数作友元】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——友元：全局函数作友元
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    class Building//房屋的类
    {
       friend void boy(Building& building);//friends全局变量是Building的好朋友，可以访问私有属性
    public:
        Building()
        {
            msittingroom = "客厅";//赋值操作
            mbedroom = "卧室";
        }
    public:
        string msittingroom;//客厅
    private:
        string mbedroom;//卧室
    };
    //全局函数
    void boy(Building& building)
    {
        cout << "boy全局函数正在访问" << building.msittingroom << endl;
        //cout << "boy全局函数正在访问" << building.mbedroom << endl;//私有属性在类外，无法访问【类内没有放置全局函数前，无法访问】
        cout << "boy全局函数正在访问" << building.mbedroom << endl;//在类内加入friend全局函数后，可以访问类内的私有属性
    }
    void test01()
    {
        Building building;
        boy(building);//传递对象
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 全局函数作友元
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20324.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20325.png)
    
    ---
    
    <aside>
    🏆 代码应用——友元：类作友元
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    class Building
    {
        friend class Goodboy;//Goodboy是Building类的好朋友【从而不仅可以访问公有内容，也可以访问私有内容】
    public:
        Building();
    public:
        string msittingroom;//客厅
    private:
        string mbedroom;//卧室
    };
    
    class Goodboy
    {
    public:
        Goodboy();
    public:
        void visit();//在无友元状态下，可以访问Building中的public属性；在友元状态下，可以访问private&public属性
        Building* building;
    };
    
    //类外写成员函数
    Building::Building()//Building类作用域下的building函数
    {
        msittingroom = "客厅";
        mbedroom = "卧室";
    }
    Goodboy::Goodboy()//Goodboy类作用域下的goodboy函数
    {
        building = new Building;//在堆区创建了一个Building对象，并且让Building*指向堆区的对象所在的地址
    }
    void Goodboy::visit()//Goodboy类作用域下的visit函数
    {
        cout << "Goodboy类正在访问" << building->msittingroom << endl;//无友元状态下已经可以访问
        cout << "Goodboy类正在访问" << building->mbedroom << endl;//无友元状态下不可以访问，将class类作为友元，使得class类可以访问building类中的私有元素
    }
    void test01()
    {
        Goodboy gb;
        gb.visit();
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类作友元
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20324.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20326.png)
    
    ---
    
    <aside>
    🏆 代码应用——友元：成员函数作友元
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    class Building;//先声明Goodboy类
    class Goodboy
    {
    public:
        Goodboy();
    public:
        void visit1();//让visit函数可以访问Building中私有成员
        void visit2();//让visit2函数不可以访问Building中私有成员
        Building* building;
    };
    class Building
    {
        friend void Goodboy::visit1();//visit1是Building类的好朋友【从而不仅可以访问公有内容，也可以访问私有内容】
        //注意事项——两个类的先后顺序不可以交换，否则将会造成友元建立不成功
    public:
        Building();
    public:
        string msittingroom;//客厅
    private:
        string mbedroom;//卧室
    };
    //类外实现成员函数
    Building::Building()//Building类作用域下的building函数
    {
        msittingroom = "客厅";
        mbedroom = "卧室";
    }
    Goodboy::Goodboy()//Goodboy类作用域下的goodboy函数
    {
        building = new Building;//在堆区创建了一个Building对象，并且让Building*指向堆区的对象所在的地址
    }
    void Goodboy::visit1()//Goodboy类作用域下的visit函数
    {
        cout << "visit函数正在访问" << building->msittingroom << endl;//无友元状态下已经可以访问
        cout << "visit函数正在访问" << building->mbedroom << endl;//无友元状态下不可以访问，将visit1作为友元，使其能能够访问Building类中的私有属性
    }
    void Goodboy::visit2()//Goodboy类作用域下的visit函数
    {
        cout << "visit函数正在访问" << building->msittingroom << endl;//无友元状态下已经可以访问
        /*cout << "visit函数正在访问" << building->mbedroom << endl;*///无友元状态下不可以访问，需要将vist2作为友元，才能访问Building类中的私有属性
    }
    void test01()
    {
        Goodboy gb;//创建类对象
        gb.visit1();//类对象访问visit01函数→调用构造函数buidling在堆区创建了Building→Building实现赋初值操作
        gb.visit2();
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 成员函数作友元
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20324.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20327.png)
    
    ---
    
- C++类和对象——运算符重载【+运算符重载、左移运算符重载、递增运算符重载、赋值运算符重载、关系运算符重载、函数调用运算符重载&仿函数&匿名函数】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——加号运算符重载【实现两个自定义数据类型相加运算】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    class person
    {
    public:
        //1.成员函数重载+号运算符
        person operator+(person& p)
        {
            person temp;
            temp.ma = this->ma+ p.ma;
            temp.mb = this->mb + p.mb;
            return temp;
        }
    public:
        int ma;
        int mb;
    };
    
    void test01()
    {
        person p1;
        p1.ma = 10;
        p1.mb = 20;
        person p2;
        p2.ma = 10;
        p2.mb = 20;
        person p3 = p1 + p2;
        /*成员函数重载调用本质
        person p3=p1.operator+(p2)*/
        cout << "p3.ma=" << p3.ma << endl;
        cout << "p3.mb=" << p3.mb << endl;
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    class person
    {
    public:
        int ma;
        int mb;
    };
    //2.全局函数重载+号运算符
    person operator+(person& p1, person& p2)
    {
        person temp;
        temp.ma = p1.ma + p2.ma;
        temp.mb = p1.mb + p2.mb;
        return temp;
    }
    //此外，运算符重载也可以实现函数重载—函数重载版本
    person operator+(person& p1, int num)
    {
        person temp;
        temp.ma = p1.ma + num;
        temp.mb = p1.mb + num;
        return temp;
    }
    void test01()
    {
        person p1;
        p1.ma = 10;
        p1.mb = 20;
        person p2;
        p2.ma = 10;
        p2.mb = 20;
        person p3 = p1 + p2;
        /*全局函数调用本质
        person p3=operator+(p1,p2)*/
        cout << "p3.ma=" << p3.ma << endl;
        cout << "p3.mb=" << p3.mb << endl;
        person p4 = p1 + 100; 
        cout << "p4.ma=" << p4.ma << endl;
        cout << "p4.mb=" << p4.mb << endl;
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 加号运算符重载
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20328.png)
        
        - 通过成员函数重载
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20329.png)
            
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20330.png)
        
        - 通过全局函数重载
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20331.png)
            
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20332.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——左移运算符重载【实现输出自定义数据类型】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
        //p,operator<<(cout)简化版本p<<cout ,由于无法利用成员函数重载<<运算符，因为无法实现cout在左侧
        //左移运算符无法实现成员函数重载，只能采用全局函数实现重载
    public:
        int ma;
        int mb;
    };
    ostream&operator<<(ostream&out, person&p)//全局函数实现左移运算符重载【p,operator<<(cout,p)简化版本cout<<p】
    {
        out << "ma=" << p.ma <<"\t" << "mb=" << p.mb;
        return out;
    }
    void test01()
    {
        person p;
        p.ma = 10;
        p.mb = 20;
        cout << p <<"hello world"<<endl;//目前为Int类型,若要实现直接输出p，需要用到左移运算符【将int类型输出为person类型】
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class person
    {
        friend ostream& operator<<(ostream& out, person& p);//利用友元，使得全局函数访问类内私有权限内容
        //p,operator<<(cout)简化版本p<<cout ,由于无法利用成员函数重载<<运算符，因为无法实现cout在左侧
        //左移运算符无法实现成员函数重载，只能采用全局函数实现重载
    public:
        person(int a, int b)
        {
            ma = a;
            mb = b;
        }
    
    private:
        int ma;
        int mb;
    };
    ostream&operator<<(ostream&out, person&p)//全局函数实现左移运算符重载【p,operator<<(cout,p)简化版本cout<<p】
    {
        cout << "ma=" << p.ma <<"\t" << "mb=" << p.mb;
        return cout;
    }
    void test01()
    {
        person p(100,100);
        cout << p << endl;//目前为Int类型,若要实现直接输出p，需要用到左移运算符【将int类型输出为person类型】
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 左移运算符重载
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20333.png)
        
        - 通过全局函数访问公有信息
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20334.png)
            
        - 通过全局函数访问私有信息
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20335.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——递增、递减运算符重载
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class myadd
    {
        friend ostream& operator<<(ostream& out,const myadd& myint);//利用友元访问类的私有权限信息
    public:
        myadd()
        {
            mnum = 0;
        }
        //重载前置++递增运算符
        myadd& operator++()
            //返回引用的原因—为了对同一个数据进行递增
            //返回值++（++num），完成内侧++num后，会赋值一个新数据，再执行外侧++,不是对同一个数据进行两次++
        {
            mnum++;//先递增
            return *this;//再返回
        }
        //重载后置++递增运算符【区分前置后置采用int,其中int代表占位参数，用于区分前置和后置递增】
        myadd operator++(int)
            //返回值的原因—由于temp存放在栈区，当前函数运行完后释放，释放后再采用引用将是非法操作
        {
            myadd temp = *this;//先记录当前结果【相当于先返回】
            mnum++;//后递增
            return temp;//最后将之前记录的结果返回
        }
    private:
        int mnum;
    };
    ostream& operator<<(ostream& cout, const myadd& myint)//重载左移运算符
    {
        cout << myint.mnum;
        return cout;
    }
    void test01()//前置递增测试函数
    {
        myadd myint;
        cout << "前置递增输出："<<++(++myint) << endl;
    }
    void test02()//后置递增测试函数
    {
        myadd myint; 
        cout << "后置递增运算先输出结果:"<<myint++ << endl;
        cout << "后置递增后运算结果:" << myint << endl;
    }
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    ```
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class myadd
    {
        friend ostream& operator<<(ostream& out,const myadd& myint);//利用友元访问类的私有权限信息
    public:
        myadd()
        {
            mnum = 0;
        }
        //重载前置--递减运算符
        myadd& operator--()
            //返回引用的原因—为了对同一个数据进行递减
            //返回值--（--num），完成内侧--num后，会赋值一个新数据，再执行外侧--,不是对同一个数据进行两次--
        {
            mnum--;//先递减
            return *this;//再返回
        }
        //重载后置--递减运算符【区分前置后置采用int,其中int代表占位参数，用于区分前置和后置递减】
        myadd operator--(int)
            //返回值的原因—由于temp存放在栈区，当前函数运行完后释放，释放后再采用引用将是非法操作
        {
            myadd temp = *this;//先记录当前结果【相当于先返回】
            mnum--;//后递减
            return temp;//最后将之前记录的结果返回
        }
    private:
        int mnum;
    };
    ostream& operator<<(ostream& cout, const myadd& myint)//重载左移运算符
    {
        cout << myint.mnum;
        return cout;
    }
    void test01()//前置递减测试函数
    {
        myadd myint;
        cout << "前置递减输出："<<--(--myint) << endl;
    }
    void test02()//后置递减测试函数
    {
        myadd myint; 
        cout << "后置递减运算先输出结果:"<<myint-- << endl;
        cout << "后置递减后运算结果:" << myint << endl;
    }
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    ```
    
    - 递增运算符重载
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20336.png)
        
        - 递增运算符重载
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20337.png)
            
        - 递减运算符重载
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20338.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——赋值运算符重载【深拷贝&浅拷贝】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    class person
    {
    public:
        person(int age)
        {
            mage = new int(age);//将年龄数据开辟在堆区【需要析构函数进行手动释放】【深浅拷贝问题】
        }
      
        person&operator=(person& p)
        {
           //应该先判断是否有属性在堆区，如果有先释放干净，然后在深拷贝
            if (mage != NULL)
            {
                delete mage;
                mage = NULL;
            }//释放堆区数据
            mage = new int(*p.mage);//深拷贝操作
    
            return *this;//返回对象本事，实现连等操作
        }
        ~person()//析构函数
        {
            if (mage != NULL)
            {
                delete mage;
                mage = NULL;
            }
        }
        int* mage;//年龄的指针
    };
    
    void test01()
    {
        person p1(18);
        person p2(20);
        person p3(30);
        p3 =p2 = p1;//赋值操作符,会使得p1内容浅拷贝到p2，因此会造成p1和p2数据地址相同，析构时会发生堆区数据重复释放造成程序崩溃
        cout << "p1的年龄为：" << *p1.mage << endl;//*解引用，取出p1地址对应的内容
        cout << "p2的年龄为：" << *p2.mage << endl;//*解引用，取出p2地址对应的内容
        cout << "p3的年龄为:" << *p3.mage << endl;//*解引用，取出p3地址对应的内容
    }
    int main()
    { 
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 赋值运算符重载
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20339.png)
        
        - 赋值运算符a=b会造成浅拷贝问题
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20340.png)
            
        - 深拷贝解决办法
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20341.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——比较运算符重载【==& ！=】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    //关系运算符重载
    class person
    {
    public:
        person(string name, int age)
        {
            mname = name;
            mage = age;
        }
        
        bool operator==(person&p)//比较运算符重载
        {
            if (this->mage == p.mage && this->mname == p.mname)
            {
                return true;
            }
            return false;
        }
        string mname;
        int mage;
    };
    void test01()
    {
        person p1("Tom", 18);
        person p2("Jack", 18);
        if (p1 == p2)
        {
            cout << "p1和p2是相等的" << endl;
        }
        else
        {
            cout << "p1和p2是不相等的" << endl;
        }
    }
    int main()
    { 
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 关系运算符重载
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20342.png)
        
        - 相等的情况
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20343.png)
            
        - 不相等的情况
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20344.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——函数调用运算符重载&仿函数&匿名函数对象
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    class myprint
    {
    public:
        
        void operator()(string test//重载函数调用运算符
        {
            cout << test << endl;
        }
    };
    void test01()
    {
        myprint mp;//创建实例化对象
        mp("hello world"); //由于使用起来非常类似函数调用，因此称为仿函数
    }
    //仿函数非常灵活，没有固定的写法
    class myadd //加法类
    {
    public:
        int operator()(int num1, int num2)
        {
            return num1 + num2;
        }
    };
    void test02()
    {
        myadd md;
        int ret=md(100, 200);
        cout << "ret=" << ret << endl;
        //匿名函数对象调用
        cout << myadd()(100, 200) << endl;//匿名函数对象，当该行执行完成后，会立即释放
    }
    int main()
    { 
        test01();
        test02();
        system("pause");
        return 0;
    }
    ```
    
    - 函数调用运算符重载
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20345.png)
        
    
    ---
    
- C++类和对象——继承【继承语法、继承方式、继承中对象模型、构造和析构的顺序、同名成员变量&成员函数处理、同名静态成员变量&成员函数处理、多继承语法、菱形继承问题&虚继承】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——继承语法
    
    </aside>
    
    ```cpp
    //普通实现页面#include<iostream>
    using namespace std;
    #include<string>
    
    class python
    {
    public:
        void header()//顶部导航栏
        {
          cout << "首页、公开课、登录、注册....(公共头部)" << endl;
        }
        void footer()
        {
            cout <<"帮助中心、交流合作、站内地图....（公共底部）" << endl;
        }
        void left()
        {
            cout << "Java、Python、C++.....(公共分类列表)" << endl;
        }
        void content()
        {
            cout << "JaVA学科视频" << endl;
        }
    };
    
    class C
    {
    public:
        void header()//顶部导航栏
        {
            cout << "首页、公开课、登录、注册....(公共头部)" << endl;
        }
        void footer()
        {
            cout << "帮助中心、交流合作、站内地图....（公共底部）" << endl;
        }
        void left()
        {
            cout << "Java、Python、C++.....(公共分类列表)" << endl;
        }
        void content()
        {
            cout << "C学科视频" << endl;
        }
    };
    class Json
    {
    public:
        void header()//顶部导航栏
        {
            cout << "首页、公开课、登录、注册....(公共头部)" << endl;
        }
        void footer()
        {
            cout << "帮助中心、交流合作、站内地图....（公共底部）" << endl;
        }
        void left()
        {
            cout << "Java、Python、C++.....(公共分类列表)" << endl;
        }
        void content()
        {
            cout << "Json学科视频" << endl;
        }
    };
    void test01()
    {
        cout << "python下载视频如下" << endl;
        python py;
        py.header();
        py.footer();
        py.left();
        py.content();
        cout << "*********************" << endl;
        cout << "C下载视频如下" << endl;
        C c;
        c.header();
        c.footer();
        c.left();
        c.content();
        cout << "*********************" << endl;
        cout << "Json下载视频如下" << endl;
        Json js;
        js.header();
        js.footer();
        js.left();
        js.content();
    
    }
    int main()
    { 
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 继承基本语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20346.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20347.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20348.png)
        
    
    ```cpp
    //继承实现页面
     #include<iostream>
    using namespace std;
    #include<string>
    
    class  Basepage//公共信息公用页面【父类】
    {
    public:
        void header()//顶部导航栏
        {
            cout << "首页、公开课、登录、注册....(公共头部)" << endl;
        }
        void footer()
        {
            cout << "帮助中心、交流合作、站内地图....（公共底部）" << endl;
        }
        void left()
        {
            cout << "Java、Python、C++.....(公共分类列表)" << endl;
        }
    };
    //将公共部分进行打包，其余私有信息在个人页面内实现
    //Java页面【子类】
    class java :public Basepage//继承的语法 class 子类：public 父类
    {
    public:
        void content()
        {
            cout << "java学科视频" << endl;
        }
    };
    //python页面
    class python :public Basepage
    {
    public:
        void content()
        {
            cout << "python学科视频" << endl;
        }
    };
    //CPP页面
    class cpp :public Basepage
    {
    public:
        void content()
        {
            cout << "cpp学科视频" << endl;
        }
    };
    void test01()
    {
        cout << "python下载视频如下" << endl;
        python py;
        py.header();
        py.footer();
        py.left();
        py.content();
        cout << "*********************" << endl;
        cout << "C下载视频如下" << endl;
        cpp cp;
        cp.header();
        cp.footer();
        cp.left();
        cp.content();
        cout << "*********************" << endl;
        cout << "Json下载视频如下" << endl;
        java ja;
        ja.header();
        ja.footer();
        ja.left();
        ja.content();
    }
    int main()
    { 
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20349.png)
    
    ---
    
    <aside>
    🏆 代码应用——继承方式
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    //继承的三种方式
    class base1
    {
    public:
        int ma;
    protected:
        int mb;
    private:
        int mc;
    };
    class son1 :public base1//公有继承—类内
    {
    public:
        void func()
        {
            ma = 10;//父类中公共权限成员到子类依然是公共权限
            mb = 20;//父类中公共权限成员到子类依然是保护权限【son1中mb是保护权限，类内可以访问，类外无法访问】
           /* mc = 30;*///父类中私有权限成员 子类无法识别
        }
    };
    void test01()//公共继承—类外
    {
        son1 s1;
        s1.ma = 100;
        /*s1.mb = 200;*///【son1中mb是保护权限，类内可以访问，类外无法访问】
    }
    
    class base2
    {
    public:
        int ma;
    protected:
        int mb;
    private:
        int mc;
    };
    class son2 :protected base2//保护继承—类内
    {
    public:
        void func()
        {
            ma = 100;//父类中公共权限到子类中变为保护权限
            mb = 100;//父类中保护权限到子类仍然是保护权限
            /*mc = 100;*///父类中私有权限成员 子类无法识别
        }
    };
    void test02()//保护继承—类外
    {
        son2 s2;
        /*s2.ma = 1000;//
        s2.mb = 2200;*///【son2中ma、mb是保护权限，类内可以访问，类外无法访问】
    }
    
    class base3
    {
    public:
        int ma;
    protected:
        int mb;
    private:
        int mc;
    };
    class son3 :private base3
    {
        void func()
        {
            ma = 100;//父类中公共成员到子类变为私有成员
            mb = 200;//父类中保护成员到子类变为私有成员
            mc = 300;//父类中私有权限成员 子类无法识别
        }
    };
    void test03()
    {
        son3 s3;
        /*s3.ma = 100;
        s3.mb = 200;
        s3 = mc = 300;*///【son3中ma、mb、mc是保护权限，类内可以访问，类外无法访问】
    }
    
    class grandson3 :public son3
    {
    public:
        void func()
        {
            //ma = 100;//由于son3中ma、mb、mc均为私有，作为grandson3的父类，则grandson3作为子类在类内无法访问父类信息
            //mb = 120;
            //mc = 130;
        }
    
    };
    ```
    
    - 继承方式
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20350.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20351.png)
        
        - 公共继承——类内：公共&保护均维持原状；类外：仅可访问公共
        - 保护继承——类内：公共&保护变为保护；类外：均不可访问
        - 私有继承——类内：公共&保护变为私有；类外：均不可访问
    
    ---
    
    <aside>
    🏆 代码应用——继承中对象模型
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    class base
    { 
    public:
    	int ma;
    protected:
    	int mb;
    private:
    	int mc;
    };
    class son :public base
    {
    public:
    	int md;
    };
    void test01()
    {
    	//所占字节为16,代表着父类中所有非静态成员属性都会被子类继承
    	//父类中私有成员属性，虽然无法访问，但确实被子类继承了【父类的3个属性+子类自身1个属性=16个字节】
    	cout << "子类所占内存空间" << sizeof(son) << endl;
    }
    int main()
    {
    	system("pause");
    	return 0;
    }
    ```
    
    - 继承中对象模型
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20352.png)
        
    
    ---
    
    - 利用开发人员命令提示符工具
        - 打开vs开发人员命令提示符
        - 跳转盘符 F:
        - 先进入到指定目录文件下——cd  F:\Visual Studio\C++  project\C++程序\C++程序\
        - 查看当前目录下的文件——dir
        - 查看继承中对象模型——cl  /d1 reportSingleClassLayout HelloWorld.cpp
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20353.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——构造和析构的顺序
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    class base
    {
    public:
    	base()
    	{
    		cout << "父类base构造函数" << endl;
    	}
    	~base()
    	{
    		cout << "父类base析构函数" << endl;
    	}
    };
    class son :public base
    {
    public:
    	son()
    	{
    		cout << "子类son构造函数" << endl;
    	}
    	~son()
    	{
    		cout << "子类son析构函数" << endl;
    	}
    };
    void test01()
    {
    	son s;//继承中构造和析构的顺序如下：构造顺序先有爸爸再有儿子，析构顺序与构造相反
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 构造和析构的顺序
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20354.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20355.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20356.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——同名成员处理【同名成员属性&成员函数处理】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class base
    {
    public:
    	base()
    	{
    		ma = 100;
    	}
    	void func()
    	{
    		cout << "父类作用域下的func函数调用"<<endl;
    	}
    	void func(int a)
    	int ma;
    };
    class son :public base
    {
    public:
    	son()
    	{
    		ma = 200;
    	}
    	void func()
    	{
    		cout << "子类作用域下的func函数调用" << endl;
    	}
    	int ma;
    };
    void test01()//同名成员问题
    {
    	son s;
    	cout << "子类中ma=" << s.ma << endl;
    	cout << "父类中ma=" << s.base::ma << endl;//1.通过子类对象访问父类中同名成员，需要加作用域
    }
    
    void test02()//同名成员函数问题
    {
    	son s;
    	s.func();//直接调用—调用的是子类中的同名成员函数
    	s.base::func();//2.通过子类访问父类中同名成员函数，需要加作用域
    	/*s.func(100);*///无法识别调用
    	//3.如果子类中出现和父类同名成员函数，子类同名成员会隐藏掉父类的属性
    	//如果要访问到父类中隐藏的同名成员函数，需要加作用域进行区分
    	s.base::func(100);//加了作用域后，可以调用
    }
    
    int main()
    {
    	test01();
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    - 同名成员处理
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20357.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20358.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——同名静态成员处理【同名静态成员变量&静态成员函数处理】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    //静态成员变量特点—所有对象都共享同一份数据，编译阶段分配内存，类内声明，类外初始化
    //静态成员函数特点—只能访问静态成员变量，不能访问非静态成员变量
    class base
    {
    public:
    	static int ma;//静态成员变量【类内声明】
    	static void func()
    	{
    		cout << "父类静态成员函数调用" << endl;
    	}
    	static void func(static int ma)
    	{
    		cout << "父类含int静态成员函数调用" << endl;
    	}
    };
    
    int base::ma = 100;;//静态成员变量【类外初始化】
    class son :public base
    {
    public:
    	static int ma;//静态成员变量【类内声明】
    	static void func()
    	{
    		cout << "子类静态成员函数调用" << endl;
    	}
    };
    int son::ma = 200;//静态成员变量【类外初始化】
    
    void test01()//同名静态成员变量处理
    {
    	//1.通过对象访问
    	cout << "通过对象访问同名静态成员变量" << endl;
    	son s;
    	cout << "子类中ma=" << s.ma << endl;
    	cout << "父类中ma=" << s.base::ma << endl;
    	//2.通过类名访问
    	cout << "通过类名访问同名静态成员变量" << endl;
    	cout << "子类中的ma=" << son::ma << endl;
    	cout << "通过子类访问父类中的ma=" << son::base::ma << "\t或者父类中的ma="<<base::ma<<endl;
    	//son::base::ma【第一个冒号代表通过类名访问、第二个冒号代表访问父类的作用域下】
    }
    void test02()//同名静态成员函数处理
    {
    	//1.通过对象访问
    	cout << "通过对象访问同名静态成员函数" << endl;
    	son s;
    	s.func();
    	s.base::func();
    	s.base::func(10);
    	//2.通过类名访问
    	cout << "通过类名访问同名静态成员函数" << endl;
    	son::func();
    	son::base::func();
    	son::base::func(10);
    }
    int main()
    {
    	/*test01();*/
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    - 同名静态成员处理
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20359.png)
        
        - 同名静态成员变量
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20360.png)
            
        - 同名静态成员函数
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20361.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——多继承语法
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class base1//父类1
    {
    public:
    
    	base1()
    	{
    		ma = 100;
    	}
    	int ma;
    };
    class base2//父类2
    {
    public:
    
    	base2()
    	{
    		ma = 200;
    	}
    	int ma;
    };
    //子类需要继承base1和base2，语法：class 子类：继承方式 父类1，继承方式 父类2
    class son:public base1,public base2
    {
    public:
    	son()
    	{
    		mc = 300;
    		md = 400;
    	}
    	int mc;
    	int md;
    };
    
    void test01()
    {
    	son s;
    	cout << "sizeof(son)内存大小为" << sizeof(son) << endl;//父类1（1个变量）+父类2（1）+子类（2）=4个变量（16字节）
    	cout << "拿去不同父类中ma时，需要加作用域base1中ma=" << s.base1::ma << endl;
    	cout << "拿去不同父类中ma时，需要加作用域base2中ma=" << s.base2::ma << endl;
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 多继承语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20362.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20363.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20364.png)
    
    ---
    
    <aside>
    🏆 代码应用——菱形继承问题&解决方法
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    class animal
    {
    public:
    	int mage;
    };
    class sheep :virtual public animal {};
    class tuo :virtual public animal {};//在继承之前加上关键字virtual变为虚继承，最上方的Animal类称为虚基类
    class sheeptuo :public sheep, public tuo{};
    void test01()
    {
    	sheeptuo st;
    	/*st.mage = 18;*///由于羊有mage,驼也有mage，因此继承不明确，需要加作用域
    	//菱形继承时，两个父类具有同名数据，需要加作用域以区分
    	st.sheep::mage = 18;
    	st.tuo::mage = 28;
    	cout << "羊的年龄:" << st.sheep::mage << endl;
    	cout << "驼的年龄:" << st.tuo::mage << endl;
    	//菱形继承时，只要有一份就可以，菱形继承导致数据有两份，资源浪费【需要采用虚继承解决菱形继承问题】
    	cout << "虚继承羊驼后的年龄：" << st.mage << endl;
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20365.png)
    
    - 菱形继承问题&虚继承
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20366.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20367.png)
    
    ---
    
    - 虚继承原理
        - 虚继承前数据结构
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20368.png)
            
        - 虚继承后数据结构
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20369.png)
            
    
    ---
    
- C++类和对象——多态【多态语法、多态原理剖析、多态案例（设计计算器）、纯虚函数和抽象类、纯虚函数和抽象案例（制作饮品）、虚析构和纯虚析构、虚析构和纯虚析构案例（电脑组装）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——多态语法
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class Animal//动物类
    {
    public:
    	 virtual void speak()//若要实现小猫在说话，该地址不能早绑定，而应改为晚绑定,在void前面加入virtual】【虚函数】
    	{
    		cout << "动物在说话" << endl;
    	}
    };
    class Cat:public Animal//派生类—猫类
    {public:
    	void speak()
    	{
    		cout << "小猫在说话" << endl;
    	}
    };
    class Dog :public Animal
    {
    public:
    	void speak()
    	{
    		cout << "小狗在说话" << endl;
    	}
    };
    //执行说话函数—地址早绑定，在编译阶段确定函数地址【dospeak引用传递用的是am，因此会执行am.speak()】
    //晚绑定—实现传入哪个对象，就执行哪个对象的程序
    
    //动态多态满足条件—1.需要有继承关系【父子关系】；
    // 2.子类要重写父类的虚函数【重载—函数名相同，参数不同；重写—函数返回值类型相同，函数名相同，参数列表相同】
    
    //动态多态的调用—1.父类指针或者引用执行子类对象
    void dospeak(Animal& animal)//animal&am=cat【父类引用指向子类对象cat】
    {
    	animal.speak();
    }
    void test01()
    {
    	Cat cat;
    	dospeak(cat);
    	Dog dog;
    	dospeak(dog);
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 多态语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20370.png)
        
        - 静态多态——函数地址早绑定，编译阶段确定
        - 动态多态——函数地址晚绑定，运行阶段确定
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20371.png)
    
    ---
    
    <aside>
    🏆 代码应用——多态的原理
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    
    class Animal//动物类
    {
    public:
    	 virtual void speak()//若要实现小猫在说话，该地址不能早绑定，而应改为晚绑定,在void前面加入virtual】【虚函数】
    	{
    		cout << "动物在说话" << endl;
    	}
    };
    class Cat:public Animal//派生类—猫类
    {public:
    	 void speak()
    	{
    		cout << "小猫在说话" << endl;
    	}
    };
    class Dog :public Animal
    {
    public:
    	void speak()
    	{
    		cout << "小狗在说话" << endl;
    	}
    };
    //执行说话函数—地址早绑定，在编译阶段确定函数地址【dospeak引用传递用的是am，因此会执行am.speak()】
    //晚绑定—实现传入哪个对象，就执行哪个对象的程序
    
    //动态多态满足条件—1.需要有继承关系【父子关系】；
    // 2.子类要重写父类的虚函数【重载—函数名相同，参数不同；重写—函数返回值类型相同，函数名相同，参数列表相同】
    
    //动态多态的调用—1.父类指针或者引用执行子类对象
    void dospeak(Animal& animal)//animal&am=cat【父类引用指向子类对象cat】
    {
    	animal.speak();
    }
    void test01()
    {
    	Cat cat;
    	dospeak(cat);
    	Dog dog;
    	dospeak(dog);
    }
    void test02()
    {
    	//cout << sizeof(Animal) << endl;//加virtual前，sizeof为1【即为空类】
    	cout << sizeof(Animal) << endl;//加virtual后，变为虚函数，sizeof为4【4个字节是虚函数指针，指针指向虚函数表，表内记录虚函数的地址】
    	cout << sizeof(Cat) << endl;
    }
    int main()
    {
    	test01();
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    - 多态的原理
        - 动物类的结构
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20372.png)
            
        - 猫类的结构
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20373.png)
            
    
    ---
    
    - 加入虚函数之前
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20374.png)
        
    - 加入虚函数之后
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20375.png)
        
    - 猫类——在没有发生重写时【表类记录的是anmial speak函数】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20376.png)
        
    - 猫类——在发生重写时【重写后，表类覆盖的是cat speak函数】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20377.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——多态案例【计算器类】
    
    </aside>
    
    ```cpp
    //普通写法
    #include<iostream>
    using namespace std;
    #include<string>
    //普通写法
    class calculate
    {
    public:
    	int getresult(string oper)
    	{
    		if (oper=="+")
    		{
    			return ma + mb;
    		}
    		else if(oper == "-")
    		{
    			return ma - mb;
    		}
    		else if (oper == "*")
    		{
    			return ma * mb;
    		}
    	}
    	int ma;
    	int mb;
    };
    void test01()
    {
    	//创建计算器对象
    	calculate c;
    	c.ma = 10;
    	c.mb = 5;
    	cout << c.ma << "+" << c.mb << "=" << c.getresult("+") << endl;
    	cout << c.ma << "-" << c.mb << "=" << c.getresult("-") << endl;
    	cout << c.ma << "*" << c.mb << "=" << c.getresult("*") << endl;
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20378.png)
    
    - 计算器类
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20379.png)
        
    
    ```cpp
    //多态写法
    #include<iostream>
    using namespace std;
    #include<string>
    
    //利用多态实现计算抽象类
    class abstractcalculate
    {
    	public:
    		virtual int getresult()
    		{
    			return 0;
    		}
    		int ma;
    		int mb;
    };
    
    class add:public abstractcalculate//加法计算器类
    {
    public:
    	virtual int getresult()
    	{
    		return ma + mb;
    	}
    };
    
    class subtract :public abstractcalculate//减法计算器类
    {
    public:
    	virtual int getresult()
    	{
    		return ma - mb;
    	}
    };
    
    class multiply:public abstractcalculate//乘法计算器类
    {
    public:
    	virtual int getresult()
    	{
    		return ma * mb;
    	}
    };
    void test02()
    {
    	//多态使用条件—父类指针或者引用指向子类对象
    	abstractcalculate* abc = new add;
    	abc->ma = 10;
    	abc->mb = 5;
    	cout <<abc->ma<< "+" << abc->mb << "=" <<abc->getresult() << endl;
    	//用完后记得将堆区数据销毁
    	delete abc;
    
    	//减法运算
    	abc = new subtract;//父类指针或者引用指向子类对象
    	abc->ma = 10;
    	abc->mb = 5;
    	cout << abc->ma << "-" << abc->mb << "=" << abc->getresult() << endl;
    	//用完后记得将堆区数据销毁
    	delete abc;
    	
    	//乘法运算
    	abc = new multiply;//父类指针或者引用指向子类对象
    	abc->ma = 10;
    	abc->mb = 5;
    	cout << abc->ma << "*" << abc->mb << "=" << abc->getresult() << endl;
    	//用完后记得将堆区数据销毁
    	delete abc;
    }
    int main()
    {
    	test02();
    	system("pause");
    	return 0;
    }
    ```
    
    ---
    
    <aside>
    🏆 代码应用——纯虚函数和抽象类
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    class base
    {
    public:
    	virtual void func() = 0;//纯虚函数【只要有一个纯虚函数，这个类为抽象类】
    	//抽象类特点—1.无法实例化对象；2.抽象类的子类必须要重写父类的纯虚函数，否则也属于抽象类
    };
    
    class son :public base
    {
    public:
    	
    	virtual void func() 
    	{
    		cout << "func子类函数调用" << endl;
    	};
    };
    class son2 :public base
    {
    public:
    
    	virtual void func()
    	{
    		cout << "func子类2函数调用" << endl;
    	};
    };
    void test01()
    {
    	/*base b;*///1.抽象类无法创建实例化对象【栈区】
    	/*new base;*///1.抽象类无法创建实例化对象【堆区】
    
    	/*son s:*///由于子类没有重写父类的纯虚函数，从而导致报错
    	son s;//重写父类的纯虚函数，可以实现子类对象
    	base* base = new son2;//【将son2改为son可以调用son函数】
    	base->func();//调用子类函数
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 纯虚函数和抽象类
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20380.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20381.png)
    
    ---
    
    <aside>
    🏆 代码应用——纯虚函数和抽象类案例【制作饮品】
    
    </aside>
    
    ```cpp
    #include<iostream>
    using namespace std;
    #include<string>
    
    class abstractdrink
    {
    public:
    	virtual void boil() = 0;//煮水纯虚函数
    	virtual void brew() = 0;//冲泡纯虚函数
    	virtual void pourincup() = 0;//倒入杯中
    	virtual void putsomething() = 0;//加入辅料
    	virtual void makedrink()
    	{
    		boil();
    		brew();
    		pourincup();
    		putsomething();
    	}
    };
    //制作咖啡
    class coffee :public abstractdrink
    {
    public:
    	virtual void boil() { cout << "煮水" << endl; };//重写父类的纯虚函数
    	virtual void brew() { cout << "冲泡咖啡" << endl; };
    	virtual void pourincup() { cout << "倒入杯中" << endl; };
    	virtual void putsomething() { cout << "加糖和牛奶" << endl; };
    };
    //制作茶叶
    class  tea :public abstractdrink
    {
    public:
    	virtual void boil() { cout << "煮水" << endl; };//重写父类的纯虚函数
    	virtual void brew() { cout << "冲泡茶叶" << endl; };
    	virtual void pourincup() { cout << "倒入杯中" << endl; };
    	virtual void putsomething() { cout << "加柠檬" << endl; };
    };
    //制作函数
    void dowork(abstractdrink* abs)//abstractdrink* abs为形参，接收dowork（）实参函数的调用
    {
    	abs->makedrink();//调用父类abstractdrink中的makedrink函数，父类再调用对应子类的函数，实现多态
    }
    
    void test01()
    {
    	dowork(new coffee);
    }
    
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 制作饮品
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20382.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20383.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20384.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——虚析构&纯虚析构
    
    </aside>
    
    ```cpp
    //虚析构
    #include<iostream>
    using namespace std;
    #include<string>
    
    class animal
    {
    public:	
    	animal()
    	{
    		cout << "animal构造函数调用" << endl;
    	}
    	virtual ~animal()//利用虚析构解决 父类指针释放子类对象时不干净的问题
    	{
    		cout << "animal析构函数调用" << endl;
    	}
    	virtual void speak() = 0;//纯虚函数
    };
    
    {
    public:
    	Cat(string name)
    	{
    		cout << "Cat构造函数调用" << endl;
    		mname=new string(name);
    	}
    	~Cat()
    	{
    		if (mname != NULL)
    		{
    			cout << "Cat析构函数调用" << endl;
    			delete mname;
    			mname = NULL;
    		}
    	}
    	virtual void speak() //重写父类的纯虚函数，否者无法子类也属于抽象类，从而无法创建子类对象
    	{
    		cout << *mname <<"小猫在说话" << endl;
    	};
    	string *mname;//利用指针将小猫姓名数据存放在堆区，从而实现传入名字
    };
    void test01()
    {
    	animal* am = new Cat("杰克");//采用父类指针指向子类对象，从而造成父类指针在析构时，不会调用子类中析构函数，导致子类如果有堆区数据，造成数据泄露
    	//对父类析构函数进行虚析构,以解决子类析构问题
    	am->speak();
    	delete am;
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    ```cpp
    //纯虚析构
    #include<iostream>
    using namespace std;
    #include<string>
    
    class animal
    {
    public:	
    	animal()
    	{
    		cout << "animal构造函数调用" << endl;
    	}
    	
    	class Cat :public animal//纯虚析构 需要申明也需要实现
    //有了虚析构之后，这个类也属于抽象类，无法实例化对象
    
    	virtual void speak() = 0;//纯虚函数
    };
    animal::~animal()
    {
    	cout << "animal纯虚析构函数调用" << endl;
    }
    class Cat :public animal
    {
    public:
    	Cat(string name)
    	{
    		cout << "Cat构造函数调用" << endl;
    		mname=new string(name);
    	}
    	~Cat()
    	{
    		if (mname != NULL)
    		{
    			cout << "Cat析构函数调用" << endl;
    			delete mname;
    			mname = NULL;
    		}
    	}
    	virtual void speak() //重写父类的纯虚函数，否者无法子类也属于抽象类，从而无法创建子类对象
    	{
    		cout << *mname <<"小猫在说话" << endl;
    	};
    	string *mname;//利用指针将小猫姓名数据存放在堆区，从而实现传入名字
    };
    void test01()
    {
    	animal* am = new Cat("杰克");//采用父类指针指向子类对象，从而造成父类指针在析构时，不会调用子类中析构函数，导致子类如果有堆区数据，造成数据泄露
    	//对父类析构函数进行虚析构,以解决子类析构问题
    	am->speak();
    	delete am;
    }
    int main()
    {
    	test01();
    	system("pause");
    	return 0;
    }
    ```
    
    - 虚析构&纯虚析构
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20385.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20386.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20387.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20388.png)
    
    ---
    
    <aside>
    🏆 代码应用——虚析构和纯虚析构案例【电脑组装】
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    class CPU
    {
    public:
        virtual void calculate() = 0;//纯虚函数【抽象的计算函数】
    };
    class Videocard
    {
    public:
        virtual void display() = 0;//纯虚函数
    };
    class Memory
    {
    public:
        virtual void storge() = 0;//纯虚函数
    };
    class Computer
    {
    public:
        Computer(CPU* cpu, Videocard* vc, Memory* mem)
        {
            mcpu = cpu;//用三个指针接收3个零件
            mvc = vc;
            mmem = mem;
        }
        //提供工作的函数—分别让各自的零件开始工作
        void work()
        {
            mcpu->calculate();//通过一个函数，提供调用接口【多态】
            mvc->display();
            mmem->storge();
        }
        ~Computer()//采用析构函数，释放3个电脑零件
        {
            if (mcpu != NULL)//若CPU在堆区的指针数据为非空，则删除堆区指针，并将其设置为空
            {
                delete mcpu;
                mcpu = NULL;
            }
            if (mvc != NULL)//若显卡在堆区的指针数据为非空，则删除堆区指针，并将其设置为空
            {
                delete mcpu;
                mcpu = NULL;
            }
            if (mmem != NULL)//若内存在堆区的指针数据为非空，则删除堆区指针，并将其设置为空
            {
                delete mcpu;
                mcpu = NULL;
            }
        }
    private:
        CPU* mcpu;//CPU零件的指针
        Videocard* mvc;//显卡零件的指针
        Memory* mmem;//内存条零件的指针
    };
    class intelCPU :public CPU//采用公共继承CPU类的属性
    {
    public:
        virtual void calculate()//父类要重写子类的纯虚函数
        {
            cout << "intel的CPU开始计算了" << endl;
        }
    };
    class intelVide :public Videocard//采用公共继承CPU类的属性
    {
    public:
        virtual void display()//父类要重写子类的纯虚函数
        {
            cout << "intel的显卡开始渲染了" << endl;
        }
    };
    class intelMemory :public Memory//采用公共继承CPU类的属性
    {
    public:
        virtual void storge()//父类要重写子类的纯虚函数
        {
            cout << "intel的内存条开始储存了" << endl;
        }
    };
    class LenovoCPU :public CPU//采用公共继承CPU类的属性
    {
    public:
        virtual void calculate()//父类要重写子类的纯虚函数
        {
            cout << "Lenovo的CPU开始计算了" << endl;
        }
    };
    class LenovoVide :public Videocard//采用公共继承CPU类的属性
    {
    public:
        virtual void display()//父类要重写子类的纯虚函数
        {
            cout << "Lenovo的显卡开始渲染了" << endl;
        }
    };
    class LenovoMemory :public Memory//采用公共继承CPU类的属性
    {
    public:
        virtual void storge()//父类要重写子类的纯虚函数
        {
            cout << "Lenovo的内存条开始储存了" << endl;
        }
    };
    void test01()
    {
        cout << "第一台电脑开始工作了" << endl;
        //第一台电脑零件
        CPU* intelcpu = new intelCPU; // 在堆区开辟一个空间，采用父类指针指向子类对象
        Videocard* intelvc = new intelVide;
        Memory* intelmem = new intelMemory;
        // 创建第一台电脑
        Computer* computer = new Computer(intelcpu, intelvc, intelmem);
        computer->work();
        //删除电脑在堆区的指针
        delete computer; 
        cout<<"第二台电脑开始工作了" << endl;
        // 创建第二台电脑
        Computer* computer2 = new Computer(new LenovoCPU, new LenovoVide, new LenovoMemory);//在堆区开辟3个内存空间，存放3个指针，然后传入Computer中
        computer2->work();
        //删除电脑在堆区的指针
        delete computer2;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 电脑组装
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20389.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20390.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20391.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20392.png)
    
    ---
    
- C++文件操作【文本文件写文件、文本文件读文件、二进制文件写文件、二进制文件读文件】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——文本文件写文件
    
    </aside>
    
    ```cpp
    #include <iostream>
    #include <fstream> // 1.包含读写文件的头文件
    
    using namespace std;
    
    void test01() {
        ofstream ofs; // 2.创建流对象名为ofs
        ofs.open("test.txt", ios::out); // 3.指定打开方式(文件路径,文件打开方式)
        ofs << "姓名:张三" << endl; // 4.写文件
        ofs << "性别:男" << endl;
        ofs << "年龄:18" << endl;
        ofs.close();//5.关闭文件
    }
    int main()
     {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 文本文件写文件
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20393.png)
        
        ---
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20394.png)
        
        ---
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20395.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——文本文件读文件
    
    </aside>
    
    ```cpp
    #include <iostream>
    #include <fstream> // 1.包含读写文件的头文件
    #include <string>
    using namespace std;
    
    void test01()
    {
        ifstream ifs; // 2.创建流对象名为ifs
        ifs.open("test.txt", ios::in); // 3.指定打开方式(文件路径,文件打开方式),并且判断是否打开成功
        if (!ifs.is_open()) 
        {
            cout << "文件打开失败" << endl;
            return;
        }
    
       char buf[1024] = { 0 }; // 4.定义缓冲区用于读取数据
    
        // 5.读取数据方式
        // while (ifs >> buf) //第一种方式
        // {
        //     cout << buf << endl;
        // }
    
        // while (ifs.getline(buf, sizeof(buf)))//第二种方式
        // {
        //     cout << buf << endl;
        // }
    
        string buf; // 使用string类型的buf【第三种方式】
        while (getline(ifs, buf)) 
        {
            cout << buf << endl;
        }
    
        ifs.close();// 6.关闭文件
    }
    
    int main() {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 文本文件读文件
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20396.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——二进制文件写文件
    
    </aside>
    
    ```cpp
    #include <iostream>
    #include <fstream> // 1.包含读写文件的头文件
    #include <string>
    using namespace std;
    
    class person//写数据类型的结构
    {
    public:
        char mname[64];//姓名
        int mage;//年龄
    };
    void test01()
    {
        ofstream ofs;//2.创建流对象名为ofs
        ofs.open("person.txt", ios::out | ios::binary);//3.指定打开方式（文件路径，文件打开方式（采用二进制））
        person p = { "张三",18 };//4.写文件—准备数据
        ofs.write((const char*)&p, sizeof(person));//取数据地址，已经数据所占的内存大小
        ofs.close();//5.关闭文件
    }
    
    int main() {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 二进制文件写文件
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20397.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——二进制文件读文件
    
    </aside>
    
    ```cpp
    #include <iostream>
    #include <fstream> // 1.包含读写文件的头文件
    #include <string>
    using namespace std;
    
    class person//写数据类型的结构
    {
    public:
        char mname[64];//姓名
        int mage;//年龄
    };
    void test01()
    {
        ifstream ifs;//2.创建流对象ifs
        ifs.open("person.txt", ios::in | ios::binary);//3.指定文件打开方式（文件路径，文件打开方式（采用二进制））
        if (!ifs.is_open())
        {
            cout << "文件打开失败" << endl;
            return;
        }
        person p;//4.读文件
        ifs.read((char*)&p, sizeof(person));
        cout << "姓名:" << p.mname << "年龄" << p.mage << endl;
        ifs.close();//5,关闭文件
    }
    
    int main() {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20398.png)
    
    - 二进制文件读文件
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20399.png)
        
    
    ---
    
- C++模板【函数模板语法、函数模板注意事项、函数模板案例（数组排序）、普通函数&函数模板区别、普通函数与函数模板调用、模板的局限性、类模板基本语法、类模板&函数模板区别、类模板成员函数创建时机、类模板对象作函数参数、类模板与继承、类模板成员函数类外实现、类模板份文件编写、类模板与友元、类模板案例（数组类封装）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——函数模板语法
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    template<typename T>//声明一个模板，告诉编译器后面代码中紧跟着的T是通用数据类型
    void Mswap(T& a, T& b)//定义一个通用的两个数据交换的函数
    {
        T temp = a;
        a = b;
        b = temp;
    }
    void test01()
    { 
        //1.自动类型推导—编译器通过定义的变量自动识别数据类习惯
        int a = 10;
        int b = 20;
        Mswap(a, b);
        cout <<"a=" << a << endl;
        cout <<"b=" << b << endl;
    
        //2.显示指定类型—<>中给予其数据类型
        Mswap<int>(a, b);
        cout << "a=" << a << endl;
        cout << "b=" << b << endl;
    }
    int main() {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 函数模板语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20400.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——函数模板注意事项
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    template<typename T>//声明一个模板，typename可以替换成class
    void Mswap(T& a, T& b)//定义一个通用的两个数据交换的函数
    {
        T temp = a;
        a = b;
        b = temp;
        //1.自动类型推导【注意事项—必须推导出一致的数据类型T才可以使用】
        int a = 10;
        /*float b = 20;*///【必须推导出一致的数据类型T才可以使用】】
        int b = 20;
        Mswap(a, b);
        cout << "a=" << a << endl;
        cout << "b=" << b << endl;
    
    }
    template<typename T>
    //2.显示指定类型[模板<>内必须要有指定的数据类型]
    void func()
    {
        cout << "函数模板调用" << endl;
    }
    void test02()
    {
        /* func<>();*///【必须要有指定的数据类型】
        func<int>();
    }
    
    int main() {
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - 函数模板注意事项
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20401.png)
        
        - 自动推导型——必须推导出一致的数据类型
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20402.png)
            
        - 显示指定类型——<>内必须要给出确定的T的数据类型
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20403.png)
            
    
    ---
    
    <aside>
    🏆 代码应用——函数模板案例（数组排序）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    // 交换功能模板
    template<class T>
    void myswap(T& a, T& b)
    {
        T temp = a;
        a = b;
        b = temp;
    }
    
    // 排序功能模板
    template<typename T>
    void mysort(T arr[], int len)
    {
        for (int i = 0; i < len; i++)
        {
            int max = i; // 假设的最大值
            for (int j = i + 1; j < len; j++)
            {
                if (arr[max] < arr[j]) // 找到数组中的最大值，并更新最大值
                {
                    max = j;
                }
            }
            if (max != i)
            {
                myswap(arr[max], arr[i]); // 交换最大值
            }
        }
    }
    
    // 打印数组模板
    template<class T>
    void printArray(T arr[], int len)
    {
        for (int i = 0; i < len; i++)
        {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
    
    // 字符数据功能测试
    void test01()
    {
        char charArr[] = "ahjywk";
        int num = sizeof(charArr) / sizeof(char) - 1; // 排除空结束符
        mysort(charArr, num);
        printArray(charArr, num);
    }
    
    // int数据功能测试
    void test02()
    {
        int intArr[] = { 3, 5, 2, 4, 1, 6 };
        int num = sizeof(intArr) / sizeof(int);
        mysort(intArr, num);
        printArray(intArr, num);
    }
    
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - 数组排序
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20404.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——普通函数&函数模板的区别
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    int myadd(int a, int b)//普通函数
    {
        return a + b;
    }
    
    template<typename T>//函数模板
    T myadd2(T a,T b)
    {
        return a + b;
    }
    void test01()
    {
        int x = 10;
        int y = 20;
        char c = 'c';
        cout << myadd(x, c) << endl;//普通函数调用时，可以发生隐式类型转换，由于两个数据类型不同，因而将c隐式类型转换成ASCII进行计算
        /*cout << myadd2(x, c) << endl;*/ //函数模板调用时间，不发生隐式类型转换，因此会报错
        //显示指定类型
        cout << myadd2<int>(x, c) << endl;//函数调用需要指定数据类型，才会发生隐式类型转换
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 普通函数&函数模板的区别
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20405.png)
        
    - 函数模板无法实现隐式类型转换
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20406.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20407.png)
    
    ---
    
    <aside>
    🏆 代码应用——普通函数&函数模板调用规则
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    void myprint(int a, int b)
    {
        cout << "普通函数调用" << endl;
    }
    
    template<typename T>
    void myprint(T a, T b)
    {
        cout << "函数模板调用" << endl;
    }
    template<typename T>
    void myprint(T a, T b, T c)
    {
        cout << "函数模板重载调用" << endl;
    }
    
    void test01()
    {
        int a = 10;
        int b = 20;
        myprint(a, b);//普通函数调用
        myprint<>(a, b);//通过空模板参数列表，强制调用函数模板
        myprint(a, b, 100);//函数模板也可以实现重载
        //如果函数模板产生更好的匹配，优先调用函数模板
        char c1 = 'a';
        char c2 = 'b';
        myprint(c1, c2);//可以看出该数据输出函数模板调用，原因如上
        
        
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 普通函数&函数模板调用规则
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20408.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20409.png)
    
    - 在程序开发时，需要避免普通函数与函数模板同时调用出现的场合
    
    ---
    
    <aside>
    🏆 代码应用——模板的局限性
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    class person
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage = age;
        }
        string mname;
        int mage;
    };
    //模板的局限性
    template<typename T>
    bool mycompare(T& a, T& b)
    {
        if (a==b)
        {
            return true;
        }
        else
        {
            return false;
        }
       
    }
    void test01()//普通比较
    {
        int a = 10;
        int b = 20;
        bool ret = mycompare(a, b);
        if (ret)
        {
            cout << "a==b" << endl;
        }
        else
        {
            cout << "a≠b" << endl;
        }
    
    }
    //利用具体化person的版本实现代码，具体化优先调用
    template<>bool mycompare(person& a, person& b)
    {
        if (a.mname == b.mname && a.mage == b.mage)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    
    void test02()//自定义类比较
    {
        person p1("Tom", 18);
        person p2("Tom", 20);
        bool ret = mycompare(p1, p2);
        if (ret)
        {
            cout << "p1==p2" << endl;
        }
        else
        {
            cout << "p1≠p2" << endl;
        }
    }
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - 模板的局限性
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20410.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20411.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——类模板基本语法
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class nametype,class agetype>//class后面为通用的数据类型
    class person
    {
    public:
        person(nametype name, agetype age)//形参
        {
            this->mname = name;
            this->mage = age;
        }
    
        void showperson()//输出内容函数
        {
            cout << "name=" << this->mname << "age=" << this->mage << endl;
        }
        
        nametype mname;
        agetype mage;
        
    };
    
    void test01()
    {
        person<string, int> p1("张三", 11);//给类模板参数赋值【实参】
        p1.showperson();
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类模板基本语法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20412.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20413.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——类模板与函数模板区别
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class nametype,class agetype = int>//class后面为通用的数据类型
    class person
    {
    public:
        person(nametype name, agetype age)
        {
            this->mname = name;
            this->mage = age;
        }
        void showperson()
        {
            cout << "name=" << this->mname << "age=" << this->mage << endl;
        }
        nametype mname;
        agetype mage;
        
    };
    
    void test01()//1.类模板没有自动类型推导使用方式
    {
        /*person p("孙悟空", 100); */ //类模板无法用自动类型推导
        person <string,int> p1 ("孙悟空", 999);//类模板只能显示指定类型实现创建实例化对象
        p1.showperson();
    }
    void test02()//2.类模板在模板参数列表中可以有默认参数
    {
        person<string> p2("猪八戒", 888);//上方定义年龄的类型默认参数int
        p2.showperson();
      
    }
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类模板与函数模板区别
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20414.png)
        
        - 类模板没有自动类型推导
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20415.png)
            
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20416.png)
    
    ---
    
    <aside>
    🏆 代码应用——类模板中成员函数创建时机
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    class person1
    {
    public:
        void showperson1()
        {
            cout << "person1 show" << endl;
        }
    };
    class person2
    {
    public:
        void showperson2()
        {
            cout << "person2 show" << endl;
        }
    };
    
    template<class T>
    class myclass
    {
    public:
        T obj;//创建通用类型成员
        //类模板中的成员函数—一开始不会被创建，因为obj一开始无法确定；而是在模板调用时再生成
        void func1()
        {
            obj.showperson1()
        }
        void func2()
        {
            obj,showperson2()
        }
    };
    void test01()
    {
        myclass<person1>m;//确定数据类型调用后，T类型确定了，从而说明函数调用才会去创建成员函数
        m.func1();//调用类对象成员函数【类型为showperson1只能调用func1】
        m.func2();//调用类对象成员函数【类型为showperson2只能调用func2】
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类模板中成员函数创建时机
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20417.png)
        
        ---
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20418.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——类模板对象作函数参数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class T1,class T2>//创建类模板
    class person
    {
    public:
        person(T1 name,T2 age)
        {
            this->mname = name;
            this->mage = age;
        }
        void showperson()
        {
            cout << "姓名：" << this->mname << "年龄：" << this->mage << endl;
        }
        T1 mname;
        T2 mage;
    };
    //1.指定传入类型—将下方模板参数列表传入
    void printperson1(person<string, int>&p)
    {
        p.showperson();
    }
    void test01()
    {
        person<string, int>p("孙悟空",100);//将孙悟空和999传到函数中，作为实参在函数体中调用成员函数
        printperson1(p);
    }
    //2.参数模板化
    template<class T1,class T2>
    void printperson2(person<T1, T2>& p)
    {
        p.showperson();
        cout << "T1的类型" << typeid(T1).name() << endl;
        cout << "T2的类型" << typeid(T2).name() << endl;//查看编译器推测出的T1的类型
    }
    void test02()
    {
        person<string, int>p("猪八戒", 99);//将孙悟空和999传到函数中，作为实参在函数体中调用成员函数
        printperson2(p);
    }
    //3.整个类模板化
    template<class T>
    void printperson3(T & p)
    {
        p.showperson();
        cout << "T2的类型" << typeid(T).name() << endl;//查看编译器推测出的T的类型
    }
    void test03()
    {
        person<string, int>p("紫霞仙子", 90);//将孙悟空和999传到函数中，作为实参在函数体中调用成员函数
        printperson3(p);
    }
    
    int main() {
        test01();
        test02();
        test03();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类模板对象作为函数参数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20419.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20420.png)
    
    ---
    
    <aside>
    🏆 代码应用——类模板与继承
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    template<class T>
    class base
    {
        T m;//创建未定式数据类型对象m
    };
    
    //class son:public base//错误的，必须要知道父类中的T的类型，才能由子类继承父类
     class son:public base<int>//目前父类中T的类型只能为int
     {
    
     };
     void test01()
     {
         son s;
     }
    //如果想灵活的指定父类中T的类型，子类也需要变为类模板
     template<class T1,class T2>
     class son1 :public base<T2>
     {
     public:
         son1()
         {
             cout << "T1的类型为" << typeid(T1).name() << endl;
             cout << "T2的类型为" << typeid(T2).name() << endl;
    
         }
         T1 obj;
     };
     void test02()
     {
         son1<int,char> s1;//类模板中创建实例化对象，必须指定数据类型
     }
    
    int main() {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20421.png)
    
    - 类模板与继承
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20422.png)
        
    - 子类需要继承父类，需要知道父类中的数据类型
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20423.png)
        
    - 继承传递路线
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20424.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——类模板成员函数类外实现
    
    </aside>
    
    ```cpp
    //类内实现
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class T1,class T2>//创建类模板
    class person
    {
    public:
        person(T1 name,T2 age)
        {
            this->mname = name;
            this->mage = age;
        }
        void showperson()
        {
            cout << "姓名：" << this->mname << "年龄：" << this->mage << endl;
        }
        T1 mname;
        T2 mage;
    };
    //1.指定传入类型—将下方模板参数列表传入
    void printperson1(person<string, int>&p)
    {
        p.showperson();
    }
    void test01()
    {
        person<string, int>p("孙悟空",100);//将孙悟空和999传到函数中，作为实参在函数体中调用成员函数
        printperson1(p);
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类模板成员函数类外实现
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20425.png)
    
    ```cpp
    //类外实现
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class T1, class T2>//创建类模板
    class Person
    {
    public:
        Person(T1 name, T2 age);//构造函数类内申明
    
        void showperson();//成员函数类内申明
       
        T1 mname;
        T2 mage;
    };
    //构造函数类外实现
    template<class T1,class T2>
    Person<T1, T2>::Person(T1 name, T2 age)
    {
        this->mname = name;
        this->mage = age;
    }
    
    //成员函数类外实现
    template<class T1,class T2>
    void Person<T1,T2>::showperson()
    {
        cout << "姓名：" << this->mname << "年龄：" << this->mage << endl;
    }
    void test01()
    {
        Person<string, int>p("孙悟空", 100);
        p.showperson();
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ---
    
    <aside>
    🏆 代码应用——类模板分文件编写
    
    </aside>
    
    ---
    
    - 头文件
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20426.png)
        
    - 源文件
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20427.png)
        
    
    ```cpp
    //头文件[person.h]
    #pragma once 
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class T1, class T2>//创建类模板
    class Person
    {
    public:
        Person(T1 name, T2 age);//构造函数类内申明
    
        void showperson();//成员函数类内申明
       
        T1 mname;
        T2 mage;
    };
    ```
    
    ```cpp
    //分文件[person.cpp]
    #include "person.h"
    
    //构造函数类外实现
    template<class T1,class T2>//使下方类外实现识别类模板
    Person<T1, T2>::Person(T1 name, T2 age)//复制类内申明，并加上作用域和模板参数
    {
        this->mname = name;
        this->mage = age;
    }
    //成员函数类外实现
    template<class T1,class T2>//使下方类外实现识别类模板
    void Person<T1,T2>::showperson()//复制类内申明，并加上作用域和模板参数列表
    {
        cout << "姓名：" << this->mname << "年龄：" << this->mage << endl;
    }
    ```
    
    ```cpp
    //主文件
    #include <iostream>
    using namespace std;
    
    //第一种解决方法，直接包含源文件
    #include "person.cpp"
    
    void test01()
    {
        Person<string, int>p("孙悟空", 100);
        p.showperson();
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类模板分文件编写
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20428.png)
        
    
    ---
    
    - 第二种解决方式
    
    ```cpp
    //类模板文件【person.hpp】
    #pragma once 
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class T1, class T2>//创建类模板
    class Person
    {
    public:
        Person(T1 name, T2 age);//构造函数类内申明
    
        void showperson();//成员函数类内申明
       
        T1 mname;
        T2 mage;
    };
    
    //构造函数类外实现
    template<class T1,class T2>//使下方类外实现识别类模板
    Person<T1, T2>::Person(T1 name, T2 age)//复制类内申明，并加上作用域和模板参数
    {
        this->mname = name;
        this->mage = age;
    }
    //成员函数类外实现
    template<class T1,class T2>//使下方类外实现识别类模板
    void Person<T1,T2>::showperson()//复制类内申明，并加上作用域和模板参数列表
    {
        cout << "姓名：" << this->mname << "年龄：" << this->mage << endl;
    }
    ```
    
    ```cpp
    //主文件
    //主文件
    #include <iostream>
    using namespace std;
    
    //第一种解决方法，将.h和.cpp内容写在一起，将后缀名改为.hpp文件
    #include "person.hpp"
    
    void test01()
    {
        Person<string, int>p("孙悟空", 100);
        p.showperson();
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ---
    
    <aside>
    🏆 代码应用——类模板与友元
    
    </aside>
    
    ```cpp
    //全局函数类内实现
    #include <iostream>
    using namespace std;
    #include<string>
    
    template<class T1, class T2>//创建类模板
    class Person
    {
     //全局函数类内实现—全局函数种传入person，利用参数模板化实现传参
        friend void showperson(Person<T1, T2> p)//添加friend 关键字，从未作为Person类的好朋友可以访问类内私有属性
        {
            cout << "姓名：" << p.mname << "年龄：" << p.mage<< endl;
        }
    public:
        
        Person(T1 name, T2 age)//构造函数
        {
            this->mname = name;
            this->mage = age;
        }
    private://为了实现友元函数类内实现和类外实现，将变量设为私有
        T1 mname;
        T2 mage;
    };
    
    void test01()
    {
        Person<string, int>p("孙悟空", 100);
        showperson(p);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 类模板与友元
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20429.png)
        
    
    ---
    
    - 类内实现&类外实现
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20430.png)
        
    - 类外实现
    
    ```cpp
    //全局函数类外实现
    #include <iostream>
    using namespace std;
    #include<string>
    
    //提前让编译器知道Person类的存在
    template<class T1, class T2>
    class Person;
    
    //提前让编译器知道全局函数的存在
    //全局函数类外实现，需要让编译器提前知道这个函数的存在，因此放在整个程序的最上方【由于含有类person因此需要在上方引入类person】
    template<class T1, class T2>//传入模板，使得编译器识别T1和T2
    void showperson(Person<T1, T2> p)
    {
        cout << "姓名：" << p.mname << "年龄：" << p.mage << endl;
    }
    
    template<class T1, class T2>//创建类模板
    class Person
    {
     //全局函数类外实现—类内申明
        friend void showperson<>(Person<T1, T2> p);//添加friend 关键字，从未作为Person类的好朋友可以访问类内私有属性
     
    //上方为全局函数类内申明，下方为函数模板的实现，需要空模板参数列表实现
    public:
        
        Person(T1 name, T2 age)//构造函数
        {
            this->mname = name;
            this->mage = age;
        }
    private://为了实现友元函数类内实现和类外实现，将变量设为私有
        T1 mname;
        T2 mage;
    };
    
    void test02()
    {
        Person<string, int>p("孙悟空", 100);
        showperson(p);
    }
    int main()
    {
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    ---
    
- C++数据容器——string（字符串）容器【string构造函数、string赋值操作、string字符串拼接、string字符串查找和替换、string字符串比较、string字符存取、string字符串插入和删除、string字串获取】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——string构造函数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()
    {
        string s1;//默认构造
        
        const char* str = "Hello World";//有参构造
        string s2(str);
        cout << "s2=" << s2 << endl;
    
        string s3(s2);//拷贝构造
        cout << "s3=" << s3 << endl;
    
        string s4(10, 'a');//使用n个字符a构造
        cout << "s4=" << s4 << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - string基本概念
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20431.png)
        
    - string构造函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20432.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——string赋值操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()
    {
        string str1;//char*类型字符串赋值给当前字符串
        str1 = "Hello  World";
        cout << "str1" << str1 << endl;
    
        string str2;//把字符串s赋值给当前的字符串
        str2 = str1;
        cout << "str2" << str2 << endl;
    
        string str3;//字符赋值给当前的字符串
        str3 = 'a';
        cout << "str3" << str3 << endl;
    
        string str4;//把字符串赋值给当前的字符串
        str4.assign("Hello C++");
        cout << "str4" << str4 << endl;
    
        string str5;//把字符传前5个字符赋值给当前的字符串
        str5.assign("Hello C++", 5);
        cout << "str5" << str5 << endl;
    
        string str6;//把字符串赋值给当前字符串
        str6.assign(str5);
        cout << "str6" << str6 << endl;
    
        string str7;//把10个字符w赋值给当前字符串
        str7.assign(10, 'w');
        cout << "str7" << str7 << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - string赋值操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20433.png)
        
    
    ---
    
    - string赋值操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20434.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——string字符串拼接【内部重载、append】
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()
    {
        string str1 = "我";//追加一个字符串，重载+=操作符
        str1 += "爱玩游戏";
        cout << "str1=" << str1 << endl;
    
       str1 += ':';//追加一个字符，重载+=操作符
       cout << "str1=" << str1 << endl;
    
       string str2;//追加一个已有的字符串对象，重载+=操作符
       str2 += " LOL/DNF ";
       cout << "str1=" << str1 << endl;
    
       string str3 = "I";//把字符串连接到当前字符串结尾
       str3.append(" love ");
       cout << "str3=" << str3 << endl;
       
       str3.append("playgame", 4);//把字符串的前4个字符连接到当前字符串结尾
       cout << "str3=" << str3 << endl;
    
       str3.append(str2);//把一个已有的字符对象内容连接到当前字符串结尾
       cout << "str3=" << str3 << endl;
    
       str3.append("ILovePlaygame ",9,4);//字符串中从第9个字符开始的之后的4个字符连接到字符串结尾
       cout << "str3=" << str3 << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - string字符串拼接
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20435.png)
        
        ---
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20436.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——string字符串查找和替换
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()//1.查找
    {
        string str1 = "abcdefgede";//查找某个字符串中de第一次出现位置，从pos位置开始查找,，默认起始位置为0位，可以修改
        //int position=str1.find("de");
        //cout << position << endl;//能查找到则返回de所在的起始位置
        //int position1 = str1.find("af");
        //cout << position1 << endl;//无法找到则返回-1
    
        int pos = str1.find("de");
        if (pos == -1)
        {
            cout << "未找到字符串" << endl;
        }
        else
        cout << "找到字符串，pos=" << pos << endl;
    
        pos = str1.rfind("de");//rfind是从右往作查找；find是从左往右查找
        cout << "pos=" << pos << endl;
    }
    
    void test02()//2.替换
    {
        string str2 = "abcdefg";//替换从pos开始的n个字符字符串为指定字符
        str2.replace(3, 5, "LV1111");
        cout << "str2=" << str2 << endl;
    }
    
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    ```
    
    - string字符串查找和替换
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20437.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20438.png)
        
        ---
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20439.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——string字符串比较【通过ASCII码进行比较】——只考虑字符串相等关系
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()//通过ASCII进行字符串比较【逐个字符进行比较】
    {
        string str1 = "aello";
        string str2 = "hello";
        if (str1.compare(str2) == 0)
        {
            cout << "str1等于str2" << endl;
        }
        else if(str1.compare(str2)>0)
        {
            cout << "str1大于str2" << endl;
        }
        else
        {
            cout << "str1小于str2" << endl;
        }
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - string字符串比较
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20440.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20441.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20442.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20443.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20444.png)
    
    ---
    
    <aside>
    🏆 代码应用——string字符存取
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()//通过ASCII进行字符串比较【逐个字符进行比较】
    {
        string str = "Hello";
        //读取字符串中的单个字符
        //1.通过[ ]访问单个字符
        for (int i = 0; i < str.size(); i++)
        {
            cout << str[i] << " ";
        }
        cout << endl;
        //2.通过at获取字符
        for (int i = 0; i < str.size(); i++)
        {
            cout << str.at(i)<< " ";
        }
        cout << endl;
    
        //修改字符串中的单个字符
        //1.通过[ ]修改单个字符
        str[0]='X';
        cout << "str=" << str << endl;
        //2.通过at修改单个字符
        str.at(1) = 'Y';
        cout << "str=" << str << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - string字符存取
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20445.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20446.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20447.png)
    
    ---
    
    <aside>
    🏆 代码应用——string字符串插入和删除
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()//通过ASCII进行字符串比较【逐个字符进行比较】
    {
        string str = "Hello";
    
        //插入
        str.insert(5, " World");//在str的5个字符位置后插入指定字符串
        cout << "str=" << str << endl;
        //删除
        str.erase(5,6);//从第5个字符位置后起擦除6个字符
        cout << "str=" << str << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - string字符串插入和删除
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20448.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20449.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20450.png)
    
    ---
    
    <aside>
    🏆 代码应用——string字串获取
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用string容器所需要的头文件
    
    void test01()//通过ASCII进行字符串比较【逐个字符进行比较】
    {
        string str = "Hello World";
    
        //截取字串
        string substr = str.substr(6, 6);//从第6个字符串后开始，截取6个字符作为一个字串
        cout << "substr=" << substr << endl;
    }
    void test02()
    {
        string email = "zhangsan&sina.com";
        //从邮件地址中获取用户名信息
        int pos = email.find("&");//先寻找
        cout << "string usename:" << email.substr(0, pos) << endl;//再截取
    }
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - string字串获取
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20451.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20452.png)
    
    ---
    
- C++数据容器——vector（单端数组）容器【初识STL、vector存放内置数据类型、vetor存放自定义数据类型、vector嵌套vector、vector构造函数、vector赋值操作、vector容量和大小、vector插入和删除、vector数据存取、vector互换容器、vector预留空、vector排序】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——初识STL
    
    </aside>
    
    - 数据容器
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20453.png)
        
    - 算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20454.png)
        
    - 迭代器
        
        【算法需要迭代器才能访问数据容器中的数据】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20455.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20456.png)
        
    
    - 初识STL
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20457.png)
        
    - STL六大组件
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20458.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——vector存放内置数据类型
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    #include<algorithm>//使用标准算法所需要的头文件
    
    //第三种遍历方式的遍历函数
    void myprint(int val)
    {
        cout << val << endl;
    }
    
    void test01()
    {
        vector<int> v;//创建一个int类型的vector容器
    
        v.push_back(10);
        v.push_back(20);//利用尾插法，向容器中插入数据
    
    	   //通过迭代器访问容器中的数据
        vector<int>::iterator itBegin = v.begin();//起始迭代器，指向容器中第一个元素
        vector<int>::iterator itEnd = v.end();//结束迭代器，指向容器最后一个元素的下一个位置
    
        //遍历方式
        //第一种遍历方式
        while (itBegin != itEnd)
        {
            cout << *itBegin << endl;//迭代器当指针，因此需要*解引用，取出数据
            itBegin++;
        }
        //第二种遍历方式
        for (vector<int>::iterator it = v.begin(); it!= v.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            cout << *it << endl;////迭代器当指针，因此需要*解引用，取出数据
        }
        //第三种遍历方式
        for_each(v.begin(), v.end(), myprint);//括号内放入（起始位置，结束位置，遍历函数）
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - vector存放内置数据类型
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20459.png)
        
    
    ---
    
    - 起始迭代器、结束迭代器指向位置
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20460.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20461.png)
    
    ---
    
    <aside>
    🏆 代码应用——vector存放自定义数据类型
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    class person
    {
    public:
        person(string name,int age)
        {
            this->mname = name;
            this->mage = age;
        }
        string mname;
        int mage;
    };
    
    void test01()
    {
        vector<person>v;//创建一个Person类型的vector容器,存放自定义的数据类型
        person p1("孙悟空", 999);
        person p2("猪八戒", 888);
    
        v.push_back(p1);
        v.push_back(p2);//利用尾插法，向容器中插入数据
    
        
        //遍历方式—for循环
        for (vector<person>::iterator it = v.begin(); it != v.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            cout <<"姓名"<<(*it).mname<<"年龄"<<(*it).mage<< endl;////迭代器当指针，因此需要*解引用,解出来后为person类型，要用.取出其属性
        }
    }
    
    void test02()
    {
        vector<person*>v;//创建一个Person类型的vector容器,存放自定义的地址
        person p1("孙悟空", 999);
        person p2("猪八戒", 888);
    
        v.push_back(&p1);
        v.push_back(&p2);//利用尾插法，向容器中插入数据【&为取出对应位置的地址】
    
        //遍历方式—for循环
        for (vector<person*>::iterator it = v.begin(); it != v.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            cout << "姓名" <<(*it)->mname<< "年龄" <<(*it)->mage<< endl;////迭代器当指针，因此需要*解引用,解出来后为person*类型，要用.取出其属性
        }
    }
    
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - vector存放自定义数据类型
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20462.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20463.png)
    
    ---
    
    <aside>
    🏆 代码应用——vector嵌套vector
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void test01()
    {
        vector<vector<int>>v;//创建大容器
    
        vector<int>v1;//创建小容器
        vector<int>v2;
        vector<int>v3;
    
        for (int i = 0; i < 3; i++)//向小容器中添加数据
        {
            v1.push_back(i + 1);
            v2.push_back(i + 2);
            v3.push_back(i + 3);
        }
        
        v.push_back(v1);//将小容器插入到大容器中
        v.push_back(v2);
        v.push_back(v3);
    
        for (vector<vector<int>>::iterator it = v.begin(); it != v.end(); it++)//二维vector容器遍历方式
        {
            /*(*it)——容器vector<int>*/
            for (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); vit++)
            {
                cout << *vit <<" ";//一行每个元素输出后相隔一个空格
            }
            cout << endl;//所有该行元素输出完后输出换行符
        }
        
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - vector嵌套vector
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20464.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20465.png)
    
    ---
    
    <aside>
    🏆 代码应用——vetor构造函数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>&v)
    {
        for (vector<int>::iterator it=v.begin(); it!=v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector<int>v1;//默认构造 
    
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        printvector(v1);
        
      
        vector<int>v2(v1.begin(), v1.end());  //通过区间方式进行构造
        printvector(v2);
    
        vector<int>v3(10, 100);//10个100方式构造
        printvector(v3);
    
        vector<int>v4(v3);//拷贝构造
        printvector(v4);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20466.png)
    
    - vetor基本概念
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20467.png)
        
        - 数组——是静态空间，初始化设定后无法进行扩展
        - Vector——可以动态扩展【可以尾插、尾删】Vector迭代器支持随机访问的迭代器
            
            ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20468.png)
            
    
    ---
    
    - vetor构造函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20469.png)
        
    
    ---
    
    ---
    
    <aside>
    🏆 代码应用——vetor赋值操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>&v)
    {
        for (vector<int>::iterator it=v.begin(); it!=v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector <int>v1;
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        printvector(v1);
    
        //operator=方式赋值
        vector<int>v2;
        v2 = v1;
        printvector(v2);
    
        //assgin方式赋值—将[begin,end)前闭后开区间的数据拷贝赋值
        vector<int>v3;
        v3.assign(v1.begin(), v1.end());
        printvector(v3);
    
        //n个element方式赋值
        vector<int>v4;
        v4.assign(10, 100);
        printvector(v4);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - vetor赋值操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20470.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20471.png)
    
    ---
    
    <aside>
    🏆 代码应用——vetor容量和大小
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>&v)
    {
        for (vector<int>::iterator it=v.begin(); it!=v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector <int>v1;
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        printvector(v1);
        //判断vector容器是否为空
        if (v1.empty() == true)
        {
            cout << "vector容器是空的" << endl;
        }
        else
        {
            cout << "vector容器存在内容了" << endl;
        }
        
        cout <<"v1的容量为：" << v1.capacity() << endl;//容器的容量
    
        cout <<"v1的元素个数为：" << v1.size() << endl;//容器中元素的个数
        
        //重新定义vector容器的大小
        v1.resize(15);//容器长度变长，则以默认值0填充新位置
        printvector(v1);
        v1.resize(15, 100);//默认值可修改
        printvector(v1);
        v1.resize(5);//容器长度变短，则多余元素会被删除
        printvector(v1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - vetor容量和大小
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20472.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——vetor插入和删除
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>&v)
    {
        for (vector<int>::iterator it=v.begin(); it!=v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector <int>v1;
    
        v1.push_back(10);//尾插插入元素
        v1.push_back(20);
        printvector(v1);
    
        v1.pop_back();//尾删删除元素
        printvector(v1);
    
        v1.insert(v1.begin(), 100);//迭代器指向位置插入元素
        printvector(v1);
    
        v1.insert(v1.end(),2,1000);//迭代器指向位置插入n个元素
        printvector(v1);
    
        v1.erase(v1.begin());//删除迭代器指向的元素
        printvector(v1);
       
        v1.erase(v1.begin()+1, v1.end()-1);//删除迭代器从start到end之间的元素
        printvector(v1);
    
        v1.clear();//清空所有元素
        v1.erase(v1.begin(), v1.end());
        printvector(v1);
    
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - vetor插入和删除
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20473.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20474.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20475.png)
    
    ---
    
    <aside>
    🏆 代码应用——vetor数据存取
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>&v)
    {
        for (vector<int>::iterator it=v.begin(); it!=v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector <int>v1;
        for (int i = 0; i < 10; i++)//采用遍历尾插的方式插入元素
        {
            v1.push_back(i);
        }
        //利用[]方式访问数组中元素
        for (int i = 0; i < v1.size(); i++)
        {
            cout << v1[i] << "  ";
        }
        cout << endl;
    
        //利用at方式访问数组中元素
        for (int i = 0; i < v1.size(); i++)
        {
            cout << v1.at(i) << "  ";
        }
        cout << endl;
        
        cout << "第一个元素为: " << v1.front() << endl;//返回容器中第一个数据元素
    
        cout << "最后一个元素为：" << v1.back() << endl;//返回容器中最后一个元素
    
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - vetor数据存取
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20476.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20477.png)
    
    ---
    
    <aside>
    🏆 代码应用——vetor互换容器
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>&v)
    {
        for (vector<int>::iterator it=v.begin(); it!=v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector <int>v1;
        vector<int>v2;
        for (int i = 1; i < 11; i++)//采用遍历尾插的方式插入元素
        {
            v1.push_back(i);
        }
        for (int i = 10; i >0; i--)
        {
            v2.push_back(i);
        }
        cout << "互换前:" << endl;
        printvector(v1);
        printvector(v2);
        //两个容器内元素进行互换
        v1.swap(v2);
        cout << "互换后:" << endl;
        printvector(v1);
        printvector(v2);
    }
    void test02()
    {
        vector<int>v;
        for (int i = 0; i < 10000; i++)//采用遍历尾插的方式插入元素
        {
            v.push_back(i);
        }
        cout << "v的容量为：" << v.capacity() << endl;
        cout<<"v的大小为："<<v.size()<<endl;
        v.resize(3);//重新指定大小
        cout << "v的容量为：" << v.capacity() << endl;//容量仍然为10000+，造成内存占有
        cout << "v的大小为：" << v.size() << endl;
        //巧用swap收缩内存
        vector<int>(v).swap(v);
        cout << "v的容量为：" << v.capacity() << endl;//会根据v的size去重新定义容器大小，释放了多余的数据容量
        cout << "v的大小为：" << v.size() << endl;
    
    }
    
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    - vetor互换容器
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20478.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20479.png)
    
    ---
    
    <aside>
    🏆 代码应用——vetor预留空间
    
    </aside>
    
    ```cpp
    //未预留空间前
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>&v)
    {
        for (vector<int>::iterator it=v.begin(); it!=v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector <int>v1;
        int num = 0;//统计内存开辟次数
        int* p = NULL;//将指针初始化为空
        for (int i = 1; i < 10000; i++)//采用遍历尾插的方式插入元素
        {
            v1.push_back(i);
            if (p != &v1[0])//如果指针地址发生变动，num++
            {
                p = &v1[0];
                num++;
            }
        }
        cout << "内存总共开辟了：" << num << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20480.png)
    
    - vetor预留空间
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20481.png)
        
    
    ---
    
    ```cpp
    //预留空间后
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    
    void printvector(vector<int>& v)
    {
        for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
        {
            cout << *it << "  ";//每输出一个元素，以空格进行分隔
    
        }
        cout << endl;//输出所有元素后，以换行符进行分隔
    }
    
    void test01()
    {
        vector <int>v1;
        v1.reserve(10000);//预留空间后
        int num1 = 0;//统计内存开辟次数
        int* p1 = NULL;//将指针初始化为空
        for (int i = 1; i < 10000; i++)//采用遍历尾插的方式插入元素
        {
            v1.push_back(i);
            if (p1 != &v1[0])//如果指针地址发生变动，num++
            {
                p1 = &v1[0];
                num1++;
            }
        }
        cout << "提前预留空间后，内存总共开辟了：" << num1 << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20482.png)
    
    ---
    
    <aside>
    🏆 代码应用——vector排序操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    #include<algorithm>//使用内置算法所需要的头文件
    
    void printdeque(const vector<int>&d)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (vector<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void test01()
    {
        vector<int>v1;
        for (int i = 10; i > 0; i--)
        {
            v1.push_back(i);
        }
        cout << "排序前;";
        printdeque(v1);
        cout << "升序排序后;";
        sort(v1.begin(), v1.end());//对数据容器元素进行排序【凡是支持随机访问呢的迭代器的容器，都可以利用sort算法直接对起进行排序】
        printdeque(v1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20483.png)
    
    ---
    
- C++数据容器——deque（双端数组）容器【deque构造函数、deque赋值操作、deque大小操作、deque插入和删除、deque数据存取、deque排序、STL案例（评委打分）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——deque构造函数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<deque>//使用deque容器所需要的头文件
    void printdeque(const deque<int>&d)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void test01()
    {
        deque<int>d1;//默认构造
        for (int i = 1; i < 10; i++)
        {
            d1.push_back(i);
        }
        printdeque(d1);
    
        deque<int>d2(d1.begin(), d1.end());//使用区间[begin,end)构造
        printdeque(d2);
    
        deque<int>d3(10,100);//构造10个100
        printdeque(d3);
    
        deque<int>d4(d1);//拷贝构造
        printdeque(d4);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - deque基本概念
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20484.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20485.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20486.png)
        
    - deque构造函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20487.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20488.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20489.png)
    
    ---
    
    <aside>
    🏆 代码应用——deque赋值操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<deque>//使用deque容器所需要的头文件
    void printdeque(const deque<int>&d)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void test01()
    {
        deque<int>d1;//默认构造
        for (int i = 1; i < 10; i++)//采用遍历尾插的方式插入元素
        {
            d1.push_back(i);
        }
        printdeque(d1);
    
        deque<int>d2;//重载等号操作符
        d2 = d1;
        printdeque(d2);
    
        deque<int>d3;//将[begin.end）区间之间的内容赋值
        d3.assign(d1.begin(), d1.end());
        printdeque(d3);
    
        deque<int>d4;//将10个100内容赋值
        d4.assign(10, 100);
        printdeque(d4);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - deque赋值操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20490.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20491.png)
    
    ---
    
    <aside>
    🏆 代码应用——deque大小操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<deque>//使用deque容器所需要的头文件
    void printdeque(const deque<int>&d)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void test01()
    {
        deque<int>d1;//默认构造
        for (int i = 1; i < 10; i++)//采用遍历尾插的方式插入元素
        {
            d1.push_back(i);
        }
        printdeque(d1);
        //判断deque容器是否为空
        if (d1.empty() == true)
        {
            cout << "deque容器是空的" << endl;
        }
        else
        {
            cout << "deque容器不是空的" << endl;
        }
    
        cout << "deque容器中的元素个数：" << d1.size() << endl;//容器中元素的个数
    
        d1.resize(15);//容器长度变长，则以默认值0填充新位置
        printdeque(d1);
        d1.resize(25,1);//默认值可修改
        printdeque(d1);
        d1.resize(5);//容器长度变短，则多余元素会被删除
        printdeque(d1);
    
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - deque大小操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20492.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20493.png)
    
    ---
    
    <aside>
    🏆 代码应用——deque插入和删除
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<deque>//使用deque容器所需要的头文件
    void printdeque(const deque<int>&d)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void test01()
    {
        deque<int>d1;
        d1.push_back(1);//头部插入一个元素
        d1.push_front(10);
        printdeque(d1);
        d1.push_back(20);//尾部插入一个元素
        printdeque(d1);
    
        d1.pop_front();//头部删除一个元素
        printdeque(d1);
        d1.pop_back();//尾部删除一个元素
        printdeque(d1);
    
        d1.insert(d1.begin(), 100);//迭代器位置插入元素
        printdeque(d1);
        d1.insert(d1.begin() + 1, 10, 100);//迭代器位置插入n个元素
        printdeque(d1);
    
        deque<int>d2;
        d2.push_back(12);
        d2.push_back(10);
        d1.insert(d1.end()-2, d2.begin(), d2.end());//按照区间进行插入【原容器的准备插入的位置，插入的容器开始位置，插入容器的结束位置】
        printdeque(d1);
      
        d1.erase(d1.begin());//删除迭代器指定的元素
        printdeque(d1);
        d1.erase(d1.begin() + 1,d1.end()-1);//删除迭代器从start到end之间的元素
        printdeque(d1);
        
        d1.clear();//清空所有元素
        d1.erase(d1.begin(), d1.end());
        printdeque(d1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - deque插入和删除
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20494.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20495.png)
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20496.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20497.png)
    
    ---
    
    <aside>
    🏆 代码应用——deque数据存取
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<deque>//使用deque容器所需要的头文件
    void printdeque(const deque<int>&d)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void test01()
    {
        deque<int>d1;
        for (int i = 0; i < 10; i++)
        {
            d1.push_back(i);
        }
        //利用[]方式访问数组元素
        for (int i = 0; i < d1.size();i++)
        {
            cout << d1[i] << " ";
        }
        cout << endl;
    
        //利用at访问数组元素
        for(int i = 0; i < d1.size(); i++)
        {
            cout << d1.at(i) << " ";
        }
       cout << endl;
    
        cout << "第一个元素为：" << d1.front() << endl;
    
        cout << "最后一个元素为：" << d1.back() << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - deque数据存取
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20498.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20499.png)
    
    ---
    
    <aside>
    🏆 代码应用——deque排序操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<deque>//使用deque容器所需要的头文件
    #include<algorithm>//使用内置算法所需要的头文件
    
    void printdeque(const deque<int>&d)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void test01()
    {
        deque<int>d1;
        for (int i = 10; i > 0; i--)
        {
            d1.push_back(i);
        }
        cout << "排序前;";
        printdeque(d1);
        cout << "升序排序后;";
        sort(d1.begin(), d1.end());//对数据容器元素进行排序【凡是支持随机访问呢的迭代器的容器，都可以利用sort算法直接对起进行排序】
        printdeque(d1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - deque排序操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20500.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20501.png)
    
    ---
    
    <aside>
    🏆 代码应用——STL案例（评委打分）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>//使用deque容器所需要的头文件
    #include<vector>//使用vector容器所需要的头文件
    #include<deque>//使用deque容器所需要的头文件
    #include<algorithm>//使用算法所需要的头文件
    #include<numeric>//使用算术生成算法所需包含的头文件
    #include <ctime>   // 使用time所需要的头文件
    
    void printdeque(const deque<int>& d)//可以在deque前面加const由读写状态改为只读状态的操作【遍历deque算法】
    {
        for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    class person//选手类
    {
    public:
        person(string name, int score)
        {
            this->mname = name;
            this->score = score;
        }
        string mname;//姓名
        int score;//分数
    
    };
    void createPerson(vector<person>& v)
    {
        string nameseed = "ABCDE";
        srand((unsigned int)time(NULL)); // 设置随机数种子
        for (int i = 0; i < 5; i++)
        {
            string name = "选手";
            name += nameseed[i];
            int score = 0;
            score += rand() % 41 + 60;//【随机生成分数】前一个数字为范围+1，后一个为起始值
            person p(name,score);
            v.push_back(p);
        }
    }
    void test01()
    {
        vector<person>v;
        createPerson(v);
        //实现遍历vector容器，取出每一个选手的姓名&分数，并将分数存到deque容器中
        deque<int>d1;
        deque<int>d2;
        for (vector<person>::iterator it = v.begin(); it != v.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            cout << "姓名" << (*it).mname << "\t分数" << (*it).score << endl;////迭代器当指针，因此需要*解引用,解出来后为person类型，要用.取出其属性
            d1.push_back((*it).score);//实现将分数存到deque容器中
            d2.push_back((*it).score);
        }
        //实现sort算法对deque容器中分数排序，去除最高分和最低分
        sort(d1.begin(), d1.end());
        d1.pop_front();
        d1.pop_back();
        printdeque(d1);
        //实现deque容器编译一遍，累计总分，获取平均分
        printdeque(d2);
        int num = accumulate(d2.begin(), d2.end(), 0);
        int person = d2.size();
        cout << person << "个人的总分为:" << num << endl;
        cout << person << "个人的平均分为" << num / person << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - STL案例（评委打分）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20502.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20503.png)
    
    ---
    
- C++数据容器——stack（先进后出）容器【stack基本概念、stack常用接口】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——stack基本概念
    
    </aside>
    
    - stack基本概
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20504.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20505.png)
    
    ---
    
    <aside>
    🏆 代码应用——stack常用接口
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<stack>//使用stack容器所需要的头文件
    
    void test01()
    {
        stack<int>s1;//创建栈区
        s1.push(10);//向栈顶添加元素
        s1.push(20);
        cout << "栈的大小" << s1.size() << endl;
        //只要栈不为空，查看栈顶，并且执行出栈操作
        while (!s1.empty())
        {
            cout << "栈顶元素为：" << s1.top() << endl;//查看栈顶的第一个元素
            s1.pop();//出栈【符合先进后出原则】
        }
       
    
        cout << "栈的大小" << s1.size() << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - stack常用接口
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20506.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20507.png)
    
    ---
    
- C++数据容器——queue（先进先出）容器【queue基本概念、queue常用接口】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——queue基本概念
    
    </aside>
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20508.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20509.png)
    
    ---
    
    <aside>
    🏆 代码应用——queue常用接口
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<queue>//使用stack容器所需要的头文件
    #include<string>
    class person
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage= age;
        }
        string mname;
        int mage;
    };
    void test01()
    {
        queue<person>q1;//创建队列
       
        person p1("唐僧", 30);//准备数据
        person p2("孙悟空", 1000);
        person p3("猪八戒", 999);
        person p4("沙僧", 888);
    
        q1.push(p1);//入队
        q1.push(p2);
        q1.push(p3);
        q1.push(p4);
        cout << "队列大小为:" << q1.size() << endl;//查看队列大小
        //判断队列是否为空
        while (!q1.empty())
        {
            cout << "查看队头元素的姓名为：" << q1.front().mname << "\t年龄为;" << q1.front().mage << endl;//查看队头
            cout << "查看队头元素的姓名为：" << q1.back().mname << "\t年龄为;" << q1.back().mage << endl;//查看队头
            q1.pop();//出队
        }
        cout << "队列大小为:" << q1.size() << endl;//查看队列大小
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - queue常用接口
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20510.png)
        
    
    ---
    
- C++数据容器—— list（非连续线性、双向迭代器）容器【list基本概念、list构造函数、list赋值和交换、list大小操作、list插入和删除、list数据存取、list反转和排序、list排序案例】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——list基本概念
    
    </aside>
    
    - list基本概念
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20511.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20512.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20513.png)
        
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20514.png)
    
    ---
    
    <aside>
    🏆 代码应用——list构造函数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<list>//使用list容器所需要的头文件
    
    void printlist(const list<int>&l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        list<int>l1;//默认构造
        l1.push_back(10);//添加数据
        l1.push_back(20);
        printlist(l1);//遍历列表
        
        list<int>l2(l1.begin(), l1.end());//使用区间[begin,end)构造
        printlist(l2);
    
        list<int>l3(10, 100);//构造10个100
        printlist(l3);
    
        list<int>l4(l1);//拷贝构造
        printlist(l4);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - list构造函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20515.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20516.png)
    
    ---
    
    <aside>
    🏆 代码应用——list赋值和交换
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<list>//使用list容器所需要的头文件
    
    void printlist(const list<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        list<int>l1;//默认构造
        for (int i = 0; i < 10; i++)
        {
            l1.push_back(i);
        }
        printlist(l1);//遍历列表
        //list赋值
        list<int>l2;//重载等号操作符赋值
        l2 = l1;
        printlist(l2);
    
        list<int>l3;//将[begin.end）区间之间的内容赋值
        l3.assign(l1.begin(), l1.end());
        printlist(l3);
    
        list<int>l4;//将10个100内容赋值
        l4.assign(10, 100);
        printlist(l4);
    
        //list交换
        cout << "交换前:" << endl;
        printlist(l1);
        printlist(l4);
        cout << "交换后;" << endl;
        l1.swap(l4);
        printlist(l1);
        printlist(l4);
        
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - list赋值和交换
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20517.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20518.png)
    
    ---
    
    <aside>
    🏆 代码应用——list大小操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<list>//使用list容器所需要的头文件
    
    void printlist(const list<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        list<int>l1;//默认构造
        for (int i = 0; i < 10; i++)
        {
            l1.push_back(i);
        }
        printlist(l1);//遍历列表
    
        //判断list容器是否为空
        if (l1.empty() == true)
        {
            cout << "list容器是空的" << endl;
        }
        else
        {
            cout << "list容器有内容存在" << endl;
            cout << "list容器中元素个数" << l1.size() << endl;//容器中元素的个数
        }
       
    
        l1.resize(15);//容器长度变长，则以默认值0填充新位置
        printlist(l1);
        l1.resize(25,100);//默认值可修改
        printlist(l1);
        l1.resize(5);//容器长度变短，则多余元素会被删除
        printlist(l1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - list大小操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20519.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20520.png)
    
    ---
    
    <aside>
    🏆 代码应用——list插入和删除
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<list>//使用list容器所需要的头文件
    
    void printlist(const list<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        list<int>l1;//默认构造
    
        l1.push_back(1);//头部插入一个元素
        l1.push_front(10);
        printlist(l1);
        l1.push_back(20);//尾部插入一个元素
        printlist(l1);
    
        l1.pop_front();//头部删除一个元素
        printlist(l1);
        l1.pop_back();//尾部删除一个元素
        printlist(l1);
    
        l1.insert(l1.end(), 100);//迭代器位置插入元素
        printlist(l1);
        l1.insert(l1.end(), 10, 100);//迭代器位置插入n个元素
        printlist(l1);
    
        list<int>l2;
        l2.push_back(12);
        l2.push_back(10);
        l1.insert(l1.begin(),l2.begin(), l2.end());//按照区间进行插入【原容器的准备插入的位置，插入的容器开始位置，插入容器的结束位置】
        printlist(l1);
    
        l1.erase(l1.begin());//删除迭代器指定的元素
        printlist(l1);
        l1.remove(100);//删除含有100的所有元素
        printlist(l1);
        
        l1.clear();//清空
        l1.erase(l1.begin(), l1.end());
        printlist(l1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - list插入和删除
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20521.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20522.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20523.png)
    
    ---
    
    <aside>
    🏆 代码应用——list数组存取
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<list>//使用list容器所需要的头文件
    
    void test01()
    {
        list<int>l1;
        l1.push_back(10);
        l1.push_back(20);
        l1.push_back(30);
        
        //l1【0】不可以用[]访问list容器中的元素【原因是—list不是连续线性空间，迭代器也不支持随机访问】
        //l1.at(0)不可以用at方式访问list容器中的元素【原因是—list不是连续线性空间，迭代器也不支持随机访问】
        cout << "第一个元素为：" << l1.front() << endl;
        cout << "最后一个元素为：" << l1.back() << endl;
        //验证迭代器是不支持随机访问的
        list<int>::iterator it = l1.begin();
        //it += 1;//迭代器不支持随机访问
        it++;//支持双向，可递增
        it--;//可递减
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - list数组存取
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20524.png)
        
        ---
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20525.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——list反转和排序
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<list>//使用list容器所需要的头文件
    
    void printlist(const list<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    bool mycompare(int l1,int l2)//自建降序排序函数
    {
        //实现降序排列
        return l1 > l2;
    }
    
    void test01()
    {
        list<int>l1;
        l1.push_back(30);
        l1.push_back(208);
        l1.push_back(77);
        
        cout << "反转前:";
        printlist(l1);
        cout << "反转后:";
        l1.reverse();//反转链表里的元素
        printlist(l1);
        
        cout << "排序前:";
        printlist(l1);
        cout << "升序排序后:";
        l1.sort();//由于列表不支持随机访问，因此只能用其特有的列表排序[升序排列]
        printlist(l1);
        cout << "降序排序后:";
        l1.sort(mycompare);//通过自建算法，实现降序排列
        printlist(l1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - list反转和排序
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20526.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20527.png)
    
    ---
    
    <aside>
    🏆 代码应用——list排序案例
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    #include<list>//使用list容器所需要的头文件
    #include<algorithm>//使用算法所需要的头文件
    #include <ctime>   // 使用time所需要的头文件
    class person//选手类
    {
    public:
        person(string name, int age,int height)
        {
            this->mname = name;
            this->mage = age;
            this->mheight = height;
        }
        string mname;//姓名
        int mage;//年龄
        int mheight;//身高
    };
    class compareperson //自定义排序算法
    {
    public:
        bool operator()(const person& p1, const person& p2)const
        {
            if (p1.mheight != p2.mheight)
            {
                return p1.mheight < p2.mheight;
            }
            else
            {
                return p1.mage > p2.mage;
            }
    
        }
    };
    
    void createPerson(list<person>& v)
    {
        string nameseed = "ABCDE";
        srand((unsigned int)time(NULL)); // 设置随机数种子
        for (int i = 0; i < 5; i++)
        {
            
            string name = "选手";
            name += nameseed[i];
            int age = 0;
            age += rand() % 21 + 20;//【随机生成年龄】前一个数字为范围+1，后一个为起始值
            int height= 0;
            height += rand() % 41 + 150;//【随机生成分数】前一个数字为范围+1，后一个为起始值
            person p(name,age,height);
            v.push_back(p);
        }
    }
    void test01()
    {
        list<person>l1;
        createPerson(l1);
        cout << "排序前"<<endl;
        for (list<person>::iterator it = l1.begin(); it != l1.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            cout << "姓名" << (*it).mname << "\t年龄" << (*it).mage<<"\t身高"<< (*it).mheight<< endl;////迭代器当指针，因此需要*解引用,解出来后为person类型，要用.取出其属性
        }
        cout << "按自定义要求进行排序后" << endl;
        l1.sort(compareperson());
        for (list<person>::iterator it = l1.begin(); it != l1.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            cout << "姓名" << (*it).mname << "\t年龄" << (*it).mage << "\t身高" << (*it).mheight << endl;////迭代器当指针，因此需要*解引用,解出来后为person类型，要用.取出其属性
        }
    
       
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - list排序案例
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20528.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20529.png)
    
    ---
    
- C++数据容器——set &multiset（自动排序）容器【set&multiset构造函数&赋值操作、set大小和交换、set插入和删除、set&multiset区别、set内置类型指定排序、set自定义数据类型排序】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——set &multiset构造函数&赋值操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    
    void printset(const set<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (set<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    
    void printMultiset(const multiset<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (set<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        set<int>s1;//默认构造
        s1.insert(440);//set只有insert插入数据的方式
        s1.insert(232);
        s1.insert(232);
        s1.insert(888);
        printset(s1);//遍历容器，数据中容器会自动被升序排序，set容器不允许插入重复值
    
        set<int>s2(s1);//拷贝构造
        printset(s2);
    
        set<int>s3;//重载等号操作符赋值
        s3 = s1;
        printset(s2);
    
        multiset<int>s4;//默认构造
        s4.insert(440);//set只有insert插入数据的方式
        s4.insert(232);
        s4.insert(232);
        s4.insert(888);
        printMultiset(s4);//遍历容器，数据中容器会自动被升序排序，multiset容器允许插入重复值
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20530.png)
    
    - set 基本概念
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20531.png)
        
    
    ---
    
    - set 构造函数&赋值操作
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20532.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——set 大小和交换
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    
    void printset(const set<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (set<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        set<int>s1;//默认构造
        s1.insert(440);//set只有insert插入数据的方式
        s1.insert(232);
        s1.insert(232);
        s1.insert(888);
        printset(s1);//遍历容器，数据中容器会自动被升序排序，set容器不允许插入重复值
    
        //判断list容器是否为空
        if (s1.empty() == true)
        {
            cout << "set容器是空的" << endl;
        }
        else
        {
            cout << "set容器有内容存在" << endl;
            cout << "set容器中元素个数" << s1.size() << endl;//容器中元素的个数
        }
        
    
        set<int>s2;
        s2.insert(93);
        s2.insert(122);
        s2.insert(80);
        cout << "交换前" << endl;
        printset(s1);
        printset(s2);
        cout << "交换后"<<endl;
        s1.swap(s2);//交换两个集合容器
        printset(s2);
        printset(s1);
    }
    int main()
    {
        test01();
       
        system("pause");
        return 0;
    }
    
    ```
    
    - set 大小和交换
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20533.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20534.png)
    
    ---
    
    <aside>
    🏆 代码应用——set 插入和删除
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    
    void printset(const set<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (set<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        set<int>s1;//默认构造
        s1.insert(440);//set只有insert插入数据的方式
        s1.insert(232);
        s1.insert(232);
        s1.insert(888);
        s1.insert(999);
        s1.insert(396);
        printset(s1);//遍历容器，数据中容器会自动被升序排序，set容器不允许插入重复值
    
        s1.erase(s1.begin());//删除迭代器所指的元素
        printset(s1);
        s1.erase(888);//删除容器中的指定元素
        printset(s1);
        s1.clear();//清空
        s1.erase(s1.begin(), s1.end()); 
        printset(s1);
    }
    int main()
    {
        test01();
       
        system("pause");
        return 0;
    }
    
    ```
    
    - set 插入和删除
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20535.png)
        
    
    ---
    
    ---
    
    <aside>
    🏆 代码应用——set 查找和统计
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    
    void printset(const set<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (set<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        set<int>s1;//默认构造
        s1.insert(440);//set只有insert插入数据的方式
        s1.insert(232);
        s1.insert(232);
        s1.insert(888);
        s1.insert(999);
        s1.insert(396);
        printset(s1);//遍历容器，数据中容器会自动被升序排序，set容器不允许插入重复值
        
        set<int>::iterator pos = s1.find(440);//采用find查找指定元素，不管找到与否，均返回迭代器，用迭代器去接收
        if (pos != s1.end())
        {
            cout << "在set中找到了元素：" << *pos<<endl;
        }
        else
        {
            cout << "在set中未找到了该元素" << endl;
        }
    
        int num1=s1.count(232);//由于set是去重的，因此统计的数字只能是1或者0
        cout<<"set中元素为232个数为："<< num1 << endl;
        multiset<int>s2;//multiset是不去重的，因此统计数字没有限制
        s2.insert(440);//set只有insert插入数据的方式
        s2.insert(232);
        s2.insert(232);
        s2.insert(888);
        s2.insert(999);
        s2.insert(396);
        int num2 = s2.count(232);
        cout << "multiset中元素为232个数为：" << num2 << endl;
    }
    int main()
    {
        test01();
       
        system("pause");
        return 0;
    }
    
    ```
    
    - set 查找和统计
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20536.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20537.png)
    
    ---
    
    <aside>
    🏆 代码应用——set&multiset区别
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    
    void printset(const set<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (set<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        set<int>s1;//默认构造
        s1.insert(440);//set只有insert插入数据的方式
        s1.insert(232);
        s1.insert(232);
        s1.insert(888);
        s1.insert(999);
        s1.insert(396);
        printset(s1);//遍历容器，数据中容器会自动被升序排序，set容器不允许插入重复值
        //验证set是否是去重的
        pair<set<int>::iterator,bool> ret= s1.insert(20);//查插入数据时，会告知是否插入成功，用pair<set迭代器>接收
        if (ret.second)
        {
            cout <<"第一次插入成功"<< endl;
        }
        else
        {
            cout << "第一次插入失败" << endl;
        }
        ret = s1.insert(20);
        if (ret.second)
        {
            cout << "第二次插入成功" << endl;
        }
        else
        {
            cout << "第二次插入失败" << endl;
        }
    
        //验证multiset是否是不去重的
        multiset<int>s2;
        s2.insert(232);
        s2.insert(232);
        s2.insert(232);
        for (multiset<int>::iterator it = s2.begin(); it != s2.end(); it++)
        {
            cout << *it << " ";
        }
        cout << endl;
        
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - set&multiset区别
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20538.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20539.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20540.png)
    
    ---
    
    <aside>
    🏆 代码应用——set内置数据类型排序
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    
    class mycompare//自建降序排列算法
    {
    public:
        bool operator()(int v1, int v2)const//第一个括号为重载符号，第二个为函数体的参数列表【构造降序仿函数】
        {
           return v1 > v2;
        }
    };
    void test01()
    {
        set<int>s1;
        s1.insert(10);
        s1.insert(50);
        s1.insert(5);
        for (set<int>::const_iterator it = s1.begin(); it != s1.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;//set的默认排序规则是升序排列
        //利用仿函数，实现降序排列
        set<int,mycompare>s2;//通过自建的降序算法实现降序排列
        s2.insert(10);
        s2.insert(50);
        s2.insert(5);
        for (set<int，mycompare>::const_iterator it = s2.begin(); it != s2.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - set内置数据类型排序
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20541.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20542.png)
    
    ---
    
    <aside>
    🏆 代码应用——set自定义数据类型排序
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    #include<string>
    
    class person
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage = age;
        }
        string mname;
        int mage;
    };
    class compareperson
    {
    public:
        bool operator()(const person& p1, const person& p2)const//第一个括号为重载符号，第二个为函数体的参数列表【构造降序仿函数】
        {
            return p1.mage > p2.mage;//按照年龄降序排序
        }
    };
    void test01()
    {
        set<person,compareperson>s1;
        person p1("刘备", 28);
        person p2("关羽", 26);
        person p3("张飞", 24);
        person p4("赵云", 22);
        s1.insert(p1);
        s1.insert(p2);
        s1.insert(p3);
        s1.insert(p4);
        //自定义数据类型，需要指定排序规则
        for (set<person,compareperson>::iterator it = s1.begin(); it != s1.end(); it++)
        {
            cout << "姓名：" << it->mname << "年龄" << it->mage << endl;
        }
        
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - set自定义数据类型排序
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20541.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20543.png)
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20544.png)
    
    ---
    
- C++数据容器—— map&multimap（键值对）容器【pair对组的创建、map&multimap构造函数&赋值操作、map大小和交换、map插入和删除、map查找和统计、map内置类型排序、map自定义数据类型排序、STL案例（员工分组）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——pair对组的创建
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<set>//使用set容器所需要的头文件
    
    void printset(const set<int>& l)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (set<int>::const_iterator it = l.begin(); it != l.end(); it++)
        {
            cout << *it << "  ";
        }
        cout << endl;
    }
    void test01()
    {
        pair<string, int>p("Tom", 20);//第一种方式
        cout <<"姓名"<<p.first<<"年龄"<<p.second<< endl;
    
        pair<string, int>p2 = make_pair("Jack", 30);//第二种方式
        cout << "姓名" << p2.first << "年龄" << p2.second << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - pair对组的创建
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20545.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20546.png)
    
    ---
    
    <aside>
    🏆 代码应用——map&multimap构造函数&赋值操作
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<map>//使用map容器所需要的头文件
    
    void printmap(map<int, int>& m)//可以在map前面加const由读写状态改为只读状态的操作
    {
        for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
        {
            cout << "键：" << (*it).first << "值：" << (*it).second << endl;
        }
        cout << endl;
    }
    
    void printMultimap(const multimap<int, int>& m) {
        for (multimap<int, int>::const_iterator it = m.begin(); it != m.end(); ++it) {
            cout << "键：" << it->first << " 值：" << it->second << endl;
        }
        cout << endl;
    }
    
    void test01()
    {
        map<int, int>m1;//默认构造
        m1.insert(pair<int, int>(1, 10));//1为键，10为值
        m1.insert(pair<int, int>(2, 20));
        m1.insert(pair<int, int>(3, 30));
        m1.insert(pair<int, int>(4, 40));
        printmap(m1);//遍历容器，map容器不允许键重复
    
        map<int, int>m2(m1);//拷贝构造
        printmap(m2);
    
        map<int, int>m3;//重载等号操作符赋值
        m3 = m1;
        printmap(m3);
    
        multimap<int, int>m4;//默认构造
        m4.insert(pair<int, int>(1, 10));//1为键，10为值
        m4.insert(pair<int, int>(2, 20));
        m4.insert(pair<int, int>(2, 30));
        m4.insert(pair<int, int>(2, 40));
        printMultimap(m4);//遍历容器,multimap容器允许键重复
    
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - map基本概念
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20547.png)
        
    
    ---
    
    - map构造函数
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20548.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20549.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20550.png)
    
    ---
    
    <aside>
    🏆 代码应用——map大小和交换
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<map>//使用map容器所需要的头文件
    
    void printmap(map<int,int>& m)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (map<int,int>::iterator it = m.begin(); it != m.end();it++)
        {
            cout << "键：" << (*it).first << "值：" << (*it).second << endl;
        }
        cout << endl;
    }
    
    void test01()
    {
        map<int, int>m1;//默认构造
        m1.insert(pair<int, int>(1, 10));//1为键，10为值
        m1.insert(pair<int, int>(2, 20));
        m1.insert(pair<int, int>(3, 30));
        m1.insert(pair<int, int>(4, 40));
        if (m1.empty() == true)
        {
            cout << "map容器是空的" << endl;
        }
        else
        {
            cout << "map容器不是空的" << endl;
            cout << "map容器中所包含的键值对个数为:" << m1.size() << endl;
        }
        
        cout << "交换前"<<endl;
        map<int, int>m2;//默认构造
        m2.insert(pair<int, int>(9, 100));//9为键，30为值
        m2.insert(pair<int, int>(8, 200));
        m2.insert(pair<int, int>(7, 300));
        printmap(m1);
        printmap(m2);
        cout << "交换后"<<endl;
        m1.swap(m2);
        printmap(m1);
        printmap(m2);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - map大小和交换
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20551.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20552.png)
    
    ---
    
    <aside>
    🏆 代码应用——map插入和删除
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<map>//使用map容器所需要的头文件
    
    void printmap(map<int,int>& m)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (map<int,int>::iterator it = m.begin(); it != m.end();it++)
        {
            cout << "键：" << (*it).first << "值：" << (*it).second << endl;
        }
        cout << endl;
    }
    
    void test01()
    {
        map<int, int>m1;//默认构造
        m1.insert(pair<int, int>(1, 10));//第一种插入方式
        m1.insert(make_pair(2, 20));//第二种插入方式
        m1.insert(map<int,int>::value_type(3, 30));//第三种插入方式
        m1[4] = 40;//第四种插入方式【不建议这种方式插入，其主要用键访问到值】
        printmap(m1);
    
        m1.erase(m1.begin());//删除迭代器指定的键值对
        printmap(m1);
        m1.erase(3);//删除对应键的键值对
        printmap(m1);
    
        m1.clear();//清空
        m1.erase(m1.begin(), m1.end());
        printmap(m1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - map插入和删除
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20553.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20554.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20555.png)
    
    ---
    
    <aside>
    🏆 代码应用——map查找和统计
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<map>//使用map容器所需要的头文件
    
    void printmap(map<int,int>& m)//可以在deque前面加const由读写状态改为只读状态的操作
    {
        for (map<int,int>::iterator it = m.begin(); it != m.end();it++)
        {
            cout << "键：" << (*it).first << "值：" << (*it).second << endl;
        }
        cout << endl;
    }
    
    void test01()
    {
        map<int, int>m1;//默认构造
        m1.insert(pair<int, int>(1, 10));//第一种插入方式
        m1.insert(make_pair(2, 20));//第二种插入方式
        m1.insert(map<int,int>::value_type(3, 30));//第三种插入方式
        m1[4] = 40;//第四种插入方式【不建议这种方式插入，其主要用键访问到值】
        printmap(m1);
        
        map<int,int>::iterator pos=m1.find(3);//用map迭代器遍历pos接收寻找结果
        if (pos != m1.end())
        {
            cout << "在键值对容器中找到了这个键：" << (*pos).first << "其值为：" << (*pos).second << endl;
        }
        else
        {
            cout << "在键值对容器中未找到这个键" << endl;
        }
    
        cout << "统计键值对中键为3的元素个数" << m1.count(3) << endl;//在map由于键不允许重复，因此结果只能为0或者1
        multimap<int, int>m2;//默认构造
        m2.insert(pair<int, int>(3, 10));
        m2.insert(pair<int, int>(3, 10));
        m2.insert(pair<int, int>(3, 10));
        cout << "统计键值对中键为3的元素个数" << m2.count(3) << endl;//在multimap允许键重复，因此结果不做限制
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - map查找和统计
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20556.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20557.png)
    
    ---
    
    <aside>
    🏆 代码应用——map内置数据类型排序
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<map>//使用map容器所需要的头文件
    
    class mycompare
    {
    public:
        bool operator()(int m1, int m2)const
        {
            return m1 > m2;
        }
    };
    void test01()
    {
        map<int, int>m1;
        m1.insert(pair<int, int>(4, 10));//第一种插入方式
        m1.insert(make_pair(3, 20));//第二种插入方式
        m1.insert(map<int,int>::value_type(2, 30));//第三种插入方式
        m1[1] = 40;//第四种插入方式【不建议这种方式插入，其主要用键访问到值】
        cout << "按照键默认升序排列为"<<endl;
        for (map<int,int>::const_iterator it = m1.begin(); it != m1.end(); it++) //默认排序是根据键的值进行从小到大的排序
        {
            cout << "key=" << it->first << "value" << it->second << endl;
        }
       
        //实现按照键进行从小到大的排序
        map<int, int, mycompare>m2;
        m2.insert(pair<int, int>(4, 10));
        m2.insert(pair<int, int>(3, 20));
        m2.insert(pair<int, int>(2, 30));
        m2.insert(pair<int, int>(1, 40));
        cout << "按照键降序排列为"<<endl;
        for (map<int, int,mycompare>::const_iterator it = m2.begin(); it != m2.end(); it++) //默认排序是根据键的值进行从小到大的排序
        {
            cout << "key=" << it->first << "value" << it->second << endl;
        }
      
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - map排序
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20558.png)
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20559.png)
    
    <aside>
    🏆 代码应用——map自定义数据类型排序
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<map>//使用map容器所需要的头文件
    
    class person
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage = age;
        }
        string mname;
        int mage;
    };
    
    class compareperson//按照年龄降序排列
    {
    public:
        bool operator()(const person&p1,const person&p2)const
        {
            return p1.mage > p2.mage;
        }
    };
    void test01()
    {
        map<person, int,compareperson>m2;
        person p1("刘备", 28);
        person p2("关羽", 30);
        person p3("张飞", 22);
        person p4("赵云", 26);
        m2.insert(pair<person,int>(p1, 1));//第一种插入方式
        m2.insert(pair<person,int>(p2, 2));
        m2.insert(pair<person,int>(p3, 3));
        m2.insert(pair<person,int>(p4, 4));
        for (map<person, int, compareperson>::iterator it = m2.begin(); it != m2.end(); it++)//实现按照年龄进行降序
        {
            cout << "键：" << it->second << "姓名：" << (it->first).mname <<"年龄："<< (it->first).mage <<endl;
        }
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20560.png)
    
    ---
    
    ---
    
    <aside>
    🏆 代码应用——STL案例（员工分组）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    #include<vector>//使用list容器所需要的头文件
    #include<map>//使用map&multimap所需要的头文件
    #include<algorithm>//使用算法所需要的头文件
    #include <ctime>   // 使用time所需要的头文件
    
    #define CEHUA 0
    #define MEISHU 1
    #define YANFA 2
    
    class person//员工类
    {
    public:
        person(string name, int salary,string group)
        {
            this->mname = name;
            this->msalary = salary;
            this->mgroup = group;
            
        }
        string mname;//姓名
        int msalary;//工资
        string mgroup;//部门
    };
    
    void createPerson(vector<person>& v)//创建员工函数
    {
        string nameseed = "ABCDEFGHIJ";
        string departments[] = { "策划", "美术", "研发" };
        srand((unsigned int)time(NULL)); // 设置随机数种子
        for (int i = 0; i < 10; i++)
        {
            
            string name = "员工";
            name += nameseed[i];
            int salary = 0;
            salary += rand() % 8000 + 2960;//【随机生成工资】
            string group;
            group += departments[rand() % 3]; //【随机生成分组】
            person p (name,salary,group);
            v.push_back(p);
        }
    }
    void setGroup(vector<person>&v,multimap<int,person>&m)//员工分组函数
    {
        for (vector<person>::iterator it = v.begin(); it != v.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            int id = rand() % 3;//产生分组
            m.insert(make_pair(id, *it));//将员工插入到具体的分组中
        }
        multimap<int, person>m1;
    }
    void showworkerbyGroup(multimap<int,person>& m)//按分组进行输出
    {
        cout << "策划部门：" << endl;
        multimap<int, person>::iterator pos=m.find(CEHUA);
        int count = m.count(CEHUA);
        int index = 0;
        for (; pos != m.end() && index < count; pos++, index++)
        {
            cout << "姓名：" << pos->second.mname << "\t工资：" << pos->second.msalary  << endl;
        }
        cout << "----------------------------" << endl;
        cout << "美术部分：" << endl;
        multimap<int, person>::iterator pos1 = m.find(MEISHU);
        count = m.count(MEISHU);
        index = 0;
        for (; pos != m.end() && index < count; pos++, index++)
        {
            cout << "姓名：" << pos->second.mname << "\t工资：" << pos->second.msalary << endl;
        }
        cout << "----------------------------" << endl;
        cout << "研发部分：" << endl;
        multimap<int, person>::iterator pos2 = m.find(YANFA);
        count = m.count(YANFA);
        index = 0;
        for (; pos != m.end() && index < count; pos++, index++)
        {
            cout << "姓名：" << pos->second.mname << "\t工资：" << pos->second.msalary << endl;
        }
    }
    void test01()
    {
        vector<person>v1;
        createPerson(v1);
        //遍历容器
        for (vector<person>::iterator it = v1.begin(); it != v1.end(); it++)//初试状态itBegin；结束条件itEnd；递增
        {
            cout << "姓名：" << (*it).mname << "\t工资：" << (*it).msalary<< endl;////迭代器当指针，因此需要*解引用,解出来后为person类型，要用.取出其属性
        }
        //员工分组
        multimap<int,person>m1;
        setGroup(v1, m1);
        //分组显示员工
        showworkerbyGroup(m1);
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 员工分组
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20561.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20562.png)
    
    ---
    
- C++函数对象【函数对象基本使用（仿函数）、一元谓词、二元谓词、内建算术仿函数、内建关系仿函数、内建逻辑仿函数】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——函数对象基本使用（仿函数）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<string>
    
    class Myadd//创建一个自定义类，实现两个数字相加
    {
    public:
        int operator()(int v1, int v2)
        {
            return v1 + v2;
        }
    };
    void test01()//1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值
    {
        Myadd myadd;//创建实例化对象
        cout << myadd(10, 10) << endl;
    }
    class Myprint
    {
    public:
        Myprint()
        {
            this->count = 0;
        }
        void operator()(string test)
        {
            cout << test << endl;
            this->count++;
        }
        int count;//定一个计数变量
    };
    void test02()//2.函数对象超出普通函数的概念，函数对象可以有自己的状态【获取该函数调用的次数状态】
    {
        Myprint myprint;//创建实例化对象
        myprint("Hello World");
        myprint("Hello World");
        myprint("Hello World");
        cout << "myprint调用的次数为：" << myprint.count << endl;
    }
    void  doprint(Myprint&mp,string test)
    {
        mp(test);
    }
    void test03()//3.函数对象可以作为参数传递
    {
        Myprint myprint;
        doprint(myprint, "这里是上海");
    }
    int main()
    {
        test01();
        test02();
        test03();
        system("pause");
        return 0;
    }
    
    ```
    
    - 函数对象基本使用
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20563.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20564.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——一元谓词
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    #include<algorithm>//使用标准算法所需要的头文件
    
    class GreaterFive//创建一个谓词【仿函数返回值类型是bool数据类型，称为谓词，由于其接收一个参数，称为一元谓词】
    {
    public:
        bool operator()(int value)
        {
            return value > 5;//大于5为真，否则为假
        }
    };
    void test01()
    {
        vector<int>v;
        for (int i = 0; i < 10; i++)
        {
            v.push_back(i);//利用尾插法输入数据
        }
        //查找容器中有没有大于5的元素
        //GreaterFiver（）匿名函数对象
        vector<int>::iterator it=find_if(v.begin(), v.end(), GreaterFive());//find_if标准算法中的常用查找算法(区间起始，区间结束，谓词)，是否找到均返回一个迭代器，需要以迭代器进行接收
        if (it == v.end())
        {
            cout << "未找到" << endl;
        }
        else
        {
            cout << "找到了大于5的数字为" <<*it<< endl;
        }
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 一元谓词
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20565.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20566.png)
    
    ---
    
    <aside>
    🏆 代码应用——二元谓词
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<vector>//使用vector容器所需要的头文件
    #include<algorithm>//使用标准算法所需要的头文件
    
    class mysort//创建一个谓词【仿函数返回值类型是bool数据类型，称为谓词，由于其接收二个参数，称为二元谓词】
    {
    public:
        bool operator()(int value1, int value2)
        {
            return value1 > value2;
        }
    
    };
    void test01()
    {
        vector<int>v;
        v.push_back(10);
        v.push_back(40);
        v.push_back(20);
        v.push_back(30);
        sort(v.begin(), v.end());
        for (vector<int>::iterator it = v.begin(); it != v.end(); it++)//采用内置的升序排列
        {
            cout << *it << " ";
        }
        cout << endl;
        //通过函数对象改变其排序为降序
        vector<int>v1;
        v1.push_back(10);
        v1.push_back(40);
        v1.push_back(20);
        v1.push_back(30);
        sort(v1.begin(), v1.end(), mysort());
        for (vector<int>::iterator it = v1.begin(); it != v1.end(); it++)//采用谓词改变其排序方法
        {
            cout << *it << " ";
        }
        cout << endl;
    
    }
    
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 二元谓词
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20567.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20568.png)
    
    ---
    
    <aside>
    🏆 代码应用——内建算术仿函数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<functional>//使用内建函数所需要的头文件
    
    //内建函数对象——算术仿函数
    //其中negate为一元仿函数，算术仿函数；其余的加减乘除取模均为二元仿函数
    void test01()//一元仿函数——取反
    {
        negate<int>n1;//创建取反对象
        cout << n1(50) << endl;//对50进行取反操作【取-号】
    }
    void test02()//二元仿函数——加减乘除取余
    {
        
        plus<int>n2;//创建加法对象
        cout << n2(50, 10) << endl;
        minus<int>n3;
        cout << n3(50, 10) << endl;
        multiplies<int>n4;
        cout << n4(5, 10) << endl;
        divides<int>n5;
        cout << n5(10, 5) << endl;
        modulus<int>n6;
        cout << n6(10, 3) << endl;  
    }
    int main()
    {
        test01();
        test02();
        system("pause");
        return 0;
    }
    
    ```
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20569.png)
    
    - 内建函数对象
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20570.png)
        
    
    ---
    
    - 内建算术仿函数【实现一些加减乘除运算】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20571.png)
        
    
    ---
    
    <aside>
    🏆 代码应用——内建关系仿函数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<functional>//使用内建函数所需要的头文件
    #include<vector>//使用vector容器所需要的头文件
    #include<algorithm>//使用内建函数所需要包含的头文件
    
    //内建函数对象——关系仿函数
    void test01()//二元仿函数
    {
        
        equal_to<int>n2;//创建等于对象【输出结果：真为1，假为0】
        cout << n2(50, 50) << endl; 
        cout << n2(50, 10) << endl; 
        not_equal_to<int>n3;//创建不等于对象
        cout << n3(50, 50) << endl;
        cout << n3(50, 10) << endl;
        greater<int>n4;//创建大于对象
        cout << n4(50, 50) << endl;
        cout << n4(50, 10) << endl;
        greater_equal<int>n5;//创建大于等于对象
        cout << n5(50, 50) << endl;
        cout << n5(50, 90) << endl;
        less<int>n6;//创建小于对象
        cout << n6(50, 50) << endl;
        cout << n6(50, 90) << endl;
        less_equal<int>n7;//创建小于等于对象
        cout << n7(50, 50) << endl;
        cout << n7(50, 10) << endl;
        //实际用处—用greater的内建立函数实升序、升序排列
        vector<int>v1;
        v1.push_back(10);
        v1.push_back(30);
        v1.push_back(20);
        v1.push_back(40);
        for (vector<int>::iterator it = v1.begin(); it!= v1.end(); it++)//遍历容器元素
        {
            cout<<*it<<" ";
        }cout << endl;
    
        sort(v1.begin(), v1.end(), greater<int>());//使用内建函数实现降序排列
        for (vector<int>::iterator it = v1.begin(); it != v1.end();it++)//遍历容器元素
        {
            cout << *it << " ";
        }cout << endl;
    
        sort(v1.begin(), v1.end(), less<int>());//使用内建函数实现升序序排列
        for (vector<int>::iterator it = v1.begin(); it != v1.end(); it++)//遍历容器元素
        {
            cout << *it << " ";
        }cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 内建关系仿函数【实际大于等于运算】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20572.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20573.png)
    
    ---
    
    <aside>
    🏆 代码应用——内建逻辑仿函数
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<functional>//使用内建函数所需要的头文件
    #include<vector>//使用vector容器所需要的头文件
    #include<algorithm>//使用算法所需要包含的头文件
    
    //内建函数对象——逻辑仿函数
    void test01()//逻辑非为一元仿函数；逻辑与&逻辑或均为二元仿函数
    {
        
        logical_and<int>n2;//创建逻辑与对象【同真为真，其余为假】
        cout << n2(1, 0) << endl;
        cout << n2(1, 10) << endl;
        logical_or<int>n3;//创建逻辑或对象【同假为假，其余为真】
        cout << n3(1, 0) << endl;
        cout << n3(0, 0) << endl;
        logical_not<int>n4;//创建逻辑非【】
        cout << n4(1) << endl;
        cout << n4(0) << endl;
    
        //实际用处—将数据进行取反放到另一个容器中
        vector<bool>v1;
        v1.push_back(true);
        v1.push_back(false);
        v1.push_back(true);
        v1.push_back(false);
        for (vector<bool>::iterator it = v1.begin(); it != v1.end(); it++)//遍历容器数据
        {
            cout << *it << " ";
        }cout << endl;
        //进行取反放到另一个容器中
        vector<bool>v2;
        v2.resize(v1.size());//将v2的大小设置为与v1一致
        transform(v1.begin(), v1.end(), v2.begin(), logical_not<bool>());//对上方的数据进行逻辑取反（原容器的开始位置，原容器的结束位位置，目标容器的起始位置，仿函数操作）
        for (vector<bool>::iterator it = v2.begin(); it != v2.end(); it++)//遍历容器数据
        {
            cout << *it << " ";
        }cout << endl;
    
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 内建逻辑仿函数【实现与或非运算】
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20574.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20575.png)
    
    ---
    
- C++算法——常用遍历方法【for_each（遍历容器）、transform（搬运到另一个容器）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——for_each算法（遍历容器）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    //普通函数
    void print(int value)
    {
        cout << value << " ";
    }
    //仿函数
    class print02
    {
    public:
        void operator()(int value)
        {
            cout << value << " ";
        }
    };
    void test01()
    {
        vector<int>v1;
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        //通过for_each算法遍历容器
        for_each(v1.begin(), v1.end(), print);//利用普通函数实现遍历操作
        cout << endl;
        for_each(v1.begin(), v1.end(), print02());//利用仿函数实现遍历操作
        cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - 常用算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20576.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20577.png)
        
    
    ---
    
    - for_each算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20578.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20579.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20580.png)
    
    ---
    
    <aside>
    🏆 代码应用——transform（搬运到另一个容器）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    //仿函数--s实现遍历容器
    class Myprint
    {
    public:
        void operator()(int value)
        {
            cout << value <<"  ";
        }
    };
    
    //仿函数——实现将容器1的数据搬运到容器2中
    class Transform
    {
    public:
        int operator()(int value)
        {
    		    value++;//实现所需的逻辑运算
            return value;
        }
    };
    void test01()
    {
        vector<int>v1;//原容器
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        vector<int>v2;//目标容器
        v2.resize(v1.size());//为目标容器分配足够的内存空间【没有这一步，程序会崩溃】
        //通过transform算法实现从一个容器搬运道另一个容器中
        transform(v1.begin(), v1.end(), v2.begin(), Transform());//将容器1中的内容搬运到容器2中
        for_each(v2.begin(), v2.end(), Myprint());//遍历新容器
        
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - transform算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20581.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20582.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20583.png)
    
    ---
    
- C++算法——常用查找算法【find（查找元素）、find_if（按条件查找）、adjacent_find（查找相邻重复元素）、binary_search（二分查找法）、count（统计元素个数）、count_if（按条件统计元素个数）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——find算法（查找元素）
    
    </aside>
    
    ```cpp
    //查找内置数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    void test01()
    {
        vector<int>v1;//原容器
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        //通过find算法查找内置数据类型指定元素,是否找到均返回迭代器位置，需要用迭代器接收
        vector<int>::iterator it = find(v1.begin(), v1.end(), 5);
        if(it!=v1.end())
        {
            cout << "在容器中找到了，其值为：" << *it << endl;
        }
        else 
        {
            cout << "在容器中未找到该值";
        }
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ```cpp
    //查找自定义数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    #include<string>//使用string容器所需包含的头文件
    class person//自定义数据类型
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage = age;
        }
        //需要重载==号，使其find能够识别如何对比Person数据类型
        bool operator==(const person& p)
        {
            if (this->mname == p.mname && this->mage == p.mage)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        string mname;
        int mage;
    };
    void test02()
    {
        vector<person>v2;
        person p1("孙悟空", 999);//创建数据
        person p2("猪八戒", 888);
        person p3("唐僧", 30);
        v2.push_back(p1);//将数据放入到容器中
        v2.push_back(p2);
        v2.push_back(p3);
        //通过find算法查找自定义数据类型指定元素【需要重载==】，是否找到均返回迭代器位置，需要用迭代器接收
        vector<person>::iterator it = find(v2.begin(), v2.end(), p2);
            if (it != v2.end())
            {
                cout << "在容器中找到了该类对象，其姓名为：" <<it->mname<<"\t年龄为:"<<it->mage << endl;
            }
            else
            {
                cout << "在容器中未找到该值";
            }
    
    }
    int main()
    {
        test02();
        system("pause");
        return 0;
    }
    ```
    
    - 常用查找算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20584.png)
        
    
    ---
    
    - find算法（查找元素）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20585.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20586.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20587.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20588.png)
    
    ---
    
    <aside>
    🏆 代码应用——find_if（按条件查找）
    
    </aside>
    
    ```cpp
    //查找内置数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    class Greatfive//仿函数——实现大于5输出值
    {
    public:
        bool operator()(int value)
        {
            return value>5;
        }
    
    };
    void test01()
    {
        vector<int>v1;//原容器
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        //通过find_if算法按条件查找内置数据类型指定元素,是否找到均返回迭代器位置，需要用迭代器接收
        vector<int>::iterator it = find_if(v1.begin(), v1.end(), Greatfive());
        if (it != v1.end())
        {
            cout << "在容器中找到了，其值为：" << *it << endl;
        }
        else
        {
            cout << "在容器中未找到该值";
        }
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ```cpp
    //查找自定义数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    #include<string>//使用string容器所需包含的头文件
    class person//自定义数据类型
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage = age;
        }
        string mname;
        int mage;
    };
    
    class Mycompare//仿函数——实现大于900的功能并返回
    {
    public:
        bool operator()(person&p)
        {
            return p.mage > 900;
        }
    };
    void test02()
    {
        vector<person>v2;
        person p1("猪八戒", 888);//创建数据
        person p2("孙悟空", 999);
        person p3("唐僧", 30);
        v2.push_back(p1);//将数据放入到容器中
        v2.push_back(p2);
        v2.push_back(p3);
        //通过find_if算法按条件查找自定义数据类型指定元素，是否找到均返回迭代器位置，需要用迭代器接收
        vector<person>::iterator it = find_if(v2.begin(), v2.end(),Mycompare());
        if (it != v2.end())
        {
            cout << "在容器中找到了该类对象，其姓名为：" << it->mname << "\t年龄为:" << it->mage << endl;
        }
        else
        {
            cout << "在容器中未找到该值";
        }
    }
    int main()
    {
        test02();
        system("pause");
        return 0;
    }
    ```
    
    - find_if（按条件查找）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20589.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20590.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20591.png)
    
    ---
    
    <aside>
    🏆 代码应用——adjacent_find（查找相邻重复元素）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void test01()
    {
        vector<int>v1;//原容器
       
        v1.push_back(90);
        v1.push_back(80);
        v1.push_back(10);
        v1.push_back(10);
        v1.push_back(50);
        v1.push_back(70);
        //通过adjacent_find算法查找相邻重复元素,是否找到均返回迭代器位置，需要用迭代器接收
        vector<int>::iterator pos = adjacent_find(v1.begin(), v1.end());
        if (pos != v1.end())
        {
            cout << "在容器中相邻重复元素，其值为：" << *pos << endl;
        }
        else
        {
            cout << "未扎到相邻重复元素";
        }
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - adjacent_find（查找相邻重复元素）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20592.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20593.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20594.png)
    
    ---
    
    <aside>
    🏆 代码应用——binary_search（二分查找法）【必须在有序序列中使用；如果是无序序列结果未知】
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void test01()
    {
        vector<int>v1;//原容器
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        //通过binary_search算法查找指定元素，会返回布尔值，需要用布尔值类型去接收【容器必须是有序序列】
        bool ret = binary_search(v1.begin(), v1.end(),9);
        if (ret=true)
        {
            cout << "在容器中找到这个值" << endl;
        }
        else
        {
            cout << "在容器中未找到这个值" << endl;
        }
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - binary_search（二分查找法）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20595.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20596.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20597.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20598.png)
    
    ---
    
    <aside>
    🏆 代码应用——count（统计元素个数）
    
    </aside>
    
    ```cpp
    //内置数据类型
    //查找内置数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    void test01()
    {
        vector<int>v1;//原容器
        v1.push_back(10);
        v1.push_back(20);
        v1.push_back(10);
        v1.push_back(30);
        v1.push_back(10);
    
        //通过count算法查找内置数据类型指定元素,会返回数字，需要用int接收
        int num = count(v1.begin(), v1.end(), 10);
        cout <<"元素为10的个数：" << num << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ```cpp
    //自定义数据类型
    //查找自定义数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    class person//自定义数据类型
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage = age;
        }
        bool operator==(const person& p)//重载==号，让count能识别自定义数据类型
        {
            if (this->mage == p.mage)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        string mname;
        int mage;
    };
    
    void test02()
    {
        vector<person>v2;
        person p1("猪八戒", 888);//创建数据
        person p2("孙悟空", 888);
        person p3("法海", 888);
        person p("龙王", 888);
        person p4("唐僧", 30);
        v2.push_back(p1);//将数据放入到容器中
        v2.push_back(p2);
        v2.push_back(p3);
        //通过find_if算法按条件查找自定义数据类型指定元素，会返回数字，需要用int接收
        int num = count(v2.begin(), v2.end(),p );
        cout << "与龙王年龄相同的人员个数为" << num << endl;    
    }
    int main()
    {
        test02();
        system("pause");
        return 0;
    }
    ```
    
    - count（统计元素个数）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20599.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20600.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20601.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20602.png)
    
    ---
    
    <aside>
    🏆 代码应用——count_if算法（按条件统计元素个数）
    
    </aside>
    
    ```cpp
    //内置数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    class Greatfive
    {
    public:
        int operator()(int value)
        {
            return value > 15;
        }
    };
    void test01()
    {
        vector<int>v1;//原容器
        v1.push_back(10);
        v1.push_back(20);
        v1.push_back(10);
        v1.push_back(30);
        v1.push_back(10);
    
        //通过count_if算法按条件统计内置数据类型,会返回数字，需要用int接收
        int num = count_if(v1.begin(), v1.end(), Greatfive());
        cout << "容器中元素大于15的个数：" << num << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    ```cpp
    //自定义数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    #include<string>//使用string容器所需包含的头文件
    class person//自定义数据类型
    {
    public:
        person(string name, int age)
        {
            this->mname = name;
            this->mage = age;
        }
        string mname;
        int mage;
    };
    
    class Mycompare//仿函数——实现大于900的功能并返回
    {
    public:
        bool operator()(person& p)
        {
            return p.mage > 900;
        }
    };
    void test02()
    {
        vector<person>v2;
        person p1("猪八戒", 888);//创建数据
        person p2("孙悟空", 999);
        person p3("龙王", 1000);
        person p4("唐僧", 30);
        v2.push_back(p1);//将数据放入到容器中
        v2.push_back(p2);
        v2.push_back(p3);
        //通过count_if算法按条件统计自定义数据类，返回数字，用int接收
        int num = count_if(v2.begin(), v2.end(), Mycompare());
        cout << "年龄大于900的个数：" << num << endl;
    }
    int main()
    {
        test02();
        system("pause");
        return 0;
    }
    ```
    
    - count_if算法（按条件统计元素个数）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20603.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20604.png)
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20605.png)
    
    ---
    
- C++算法——常用排序算法【sort（对容器元素进行排序）、random_shuffle（指定范围内元素随机调整次序）、merge（两个容器元素合并，并储存在另一个容器中）、reverse（将容器内容元素进行反转）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——sort算法（对容器元素进行排序）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<functional>//使用内建函数所需要的头文件
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    class Mycompare
    {
    public:
        int operator()(int value1, int value2)
        {
            return value1 > value2;
        }
    };
    void Myprint(int value)
    {
        cout << value << " ";
    }
    void test01()
    {
        vector<int>v1;
        v1.push_back(10);
        v1.push_back(50);
        v1.push_back(30);
        v1.push_back(90);
        //利用sort进行升序排列
        sort(v1.begin(), v1.end());
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
        //利用内建关系函数实现降序排列
        sort(v1.begin(), v1.end(), greater<int>());
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
        //利用仿函数实现降序排列
        sort(v1.begin(), v1.end(), Mycompare());
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 常用排序算法
    
    ---
    
    - sort算法（对容器元素进行排序）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20606.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20607.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20608.png)
    
    ---
    
    <aside>
    🏆 代码应用——random_shuffle算法（指定范围内元素随机调整次序）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    #include<ctime>//使用time所需包含的头文件
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    void test01()
    {
        srand((unsigned int)time(NULL));//根据时间生成随机数种子
        vector<int>v1;
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        //利用洗牌算法实现容器元素打乱的功能
        for_each(v1.begin(), v1.end(), Myprint);//洗牌前
        cout << endl;
        random_shuffle(v1.begin(), v1.end());//洗牌后
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - random_shuffle算法（指定范围内元素随机调整次序）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20609.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20610.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20611.png)
    
    ---
    
    <aside>
    🏆 代码应用——merge算法（两个容器元素合并，并储存在另一个容器中）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    void test01()
    {
        vector<int>v1;
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        vector<int>v2;
        for (int i = 10; i < 20; i++)
        {
            v1.push_back(i);
        }
       
        //通过merge实现将两个容器元素合并，并存储到另一个容器中【两个容器均为有序数列，且均为同一方向】
        vector<int>v3;
        v3.resize(v1.size() + v2.size());//需要先新目标容器安排足够的内存空间
        merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());//（容器1开始位置，容器1结束位置，容器2开始位置，容器2结束位置，合并后容器的开始位置）
        for_each(v3.begin(), v3.end(), Myprint);
        cout << endl;
    
      
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - merge算法（两个容器元素合并，并储存在另一个容器中））
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20612.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20613.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20614.png)
    
    ---
    
    <aside>
    🏆 代码应用——reverse算法（将容器内容元素进行反转）
    
    </aside>
    
    ```cpp
    //查找内置数据类型
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    void test01()
    {
        vector<int>v1;
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        
        //通过reverse实现将容器内元素内容进行反转
        cout << "反转前：";
        for_each(v1.begin(), v1.end(), Myprint);
        cout << "\n反转后：";
        reverse(v1.begin(), v1.end());
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
    
      
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - reverse算法（将容器内容元素进行反转）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20615.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20616.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20617.png)
    
    ---
    
- C++算法——常用拷贝和替换算法【copy（指定范围内的元素拷贝到另一容器中）、replace（将指定范围内的旧元素改为新元素）、replace_if（将指定范围内的旧元素替换新元素）、swap（互换两个容器的元素）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——copy算法（指定范围内的元素拷贝到另一容器中）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    void test01()
    {
        vector<int>v1;
        for (int i = 0; i < 10; i++)
        {
            v1.push_back(i);
        }
        //利用copy算法将v1容器中指定范围年内的元素拷贝到另一个容器中【需要给新容器提前开辟空间】
        vector<int>v2;
        v2.resize(v1.size() - 1);//先给新容器安排足够的内存空间
        copy(v1.begin() + 1, v1.end(), v2.begin());
        for_each(v2.begin(), v2.end(), Myprint);
        cout << endl;
    
      
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 常用拷贝和替换算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20618.png)
        
    
    ---
    
    - copy算法（指定范围内的元素拷贝到另一容器中）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20619.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20620.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20621.png)
    
    ---
    
    <aside>
    🏆 代码应用——replace算法（将指定范围内的旧元素改为新元素）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    void test01()
    {
        vector<int>v1;
        v1.push_back(20);
        v1.push_back(10);
        v1.push_back(30);
        v1.push_back(10);
        v1.push_back(50);
        v1.push_back(10);
        //利用replace将容器内指定范围的旧元素修改为新元素
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
        replace(v1.begin(), v1.end(), 10, 5);
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
    
      
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - replace算法（将指定范围内的旧元素改为新元素）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20622.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20623.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20624.png)
    
    ---
    
    <aside>
    🏆 代码应用——replace_if算法（将指定范围内的旧元素替换新元素）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    class Greater5
    {
    public:
        int operator()(int value)
        {
            return value > 10;
        }
    };
    void test01()
    {
        vector<int>v1;
        v1.push_back(20);
        v1.push_back(10);
        v1.push_back(30);
        v1.push_back(10);
        v1.push_back(50);
        v1.push_back(10);
        //利用replace_if将容器内指定范围的满足条件的旧元素修改为新元素
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
        replace_if(v1.begin(), v1.end(), Greater5(), 5);
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
    
      
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - replace_if算法（将指定范围内的旧元素替换新元素）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20625.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20626.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20627.png)
    
    ---
    
    <aside>
    🏆 代码应用——swap算法（互换两个容器的元素）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    void test01()
    {
        vector<int>v1;
        v1.push_back(20);
        v1.push_back(10);
        v1.push_back(30);
        v1.push_back(10);
        v1.push_back(50);
        v1.push_back(10);
        vector<int>v2;
        for (int i = 0; i < 10; i++)
        {
            v2.push_back(i);
        }
        //使用swap互换两个容器的元素【互换的两个容器的类型必须一致】
        cout << "互换前";
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
        for_each(v2.begin(), v2.end(), Myprint);
        cout << endl;
        cout << "互换后";
        swap(v1, v2);//互换的两个容器的数据类型必须一致
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
        for_each(v2.begin(), v2.end(), Myprint);
        cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - swap算法（互换两个容器的元素）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20628.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20629.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20630.png)
    
    ---
    
- C++算法——常用算术生成算法【accumulate（计算容器中元素累计总和）、fill（向容器中添加元素）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——accumulate算法（计算容器中元素累计总和）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    #include<numeric>//使用算术生成算法所需包含的头文件
    
    void test01()
    {
     
        vector<int>v1;
        for (int i = 0; i <=100; i++)
        {
            v1.push_back(i);
        }
        //使用accumulate计算区间容器元素累计总和
        int num = accumulate(v1.begin(), v1.end(), 0);//（区间起始位置，区间结束位置，初始值）
        cout << "数据总和为" << num << endl;
        
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 常用算术生成算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20631.png)
        
    - accumulate算法（计算容器中元素累计总和）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20632.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20633.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20634.png)
    
    ---
    
    <aside>
    🏆 代码应用——fill算法（向容器中添加元素）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    #include<numeric>//使用算术生成算法所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    
    void test01()
    {
     
        vector<int>v1;
        for (int i = 0; i <10; i++)
        {
            v1.push_back(i);
        }
       //使用fill实现向容器中指定区间的内容填充为指定的元素
        cout << "填充前" ;
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
        fill(v1.begin() + 1, v1.end() - 1, 5);
        cout << "填充后";
        for_each(v1.begin(), v1.end(), Myprint);
        cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - fill算法（向容器中添加元素）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20635.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20636.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20637.png)
    
    ---
    
- C++算法——常用集合算法【set_intersection（求两个容器的交集）、set_union（求两个容器的并集）、set_difference（求两个容器的差接）】[⬆️](https://www.notion.so/C-4fd88053b6e74496b4b089bee476aad8?pvs=21)
    
    <aside>
    🏆 代码应用——set_intersection算法 （求两个容器的交集）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    
    void test01()
    {
     
        vector<int>v1;
        vector<int>v2;
        for (int i = 0; i <10; i++)
        {
            v1.push_back(i);
            v2.push_back(i + 5);
        }
        //使用set_intersection计算两个容器交集
        vector<int>v3;
        v3.resize(min(v1.size(),v2.size()));//给目标集合分配足够的内存空间【开辟空间最极限是取小容器】
        vector<int>::iterator itend= set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());//可能交集没有设想的这么大，因此用迭代器接收其交集的结束位置
        for_each(v3.begin(),itend, Myprint);
        cout << endl;
       
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - 常用的集合算法
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20638.png)
        
    - set_intersection算法 （求两个容器的交集）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20639.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20640.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20641.png)
    
    ---
    
    <aside>
    🏆 代码应用——set_union算法（求两个容器的并集）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    
    void test01()
    {
     
        vector<int>v1;
        vector<int>v2;
        for (int i = 0; i <10; i++)
        {
            v1.push_back(i);
            v2.push_back(i + 5);
        }
        //使用set_union算法（求两个容器的并集）
     vector<int>v4;
     v4.resize(v1.size()+v2.size());//给目标集合分配足够的内存空间【开辟空间最极限是取两个容器之和】
     vector<int>::iterator itend2 = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v4.begin());//可能并集没有设想的这么大，因此用迭代器接收其并集的结束位置
     for_each(v4.begin(), itend2, Myprint);
     cout << endl;
     }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    ```
    
    - set_union算法（求两个容器的并集）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20642.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20643.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20644.png)
    
    ---
    
    <aside>
    🏆 代码应用——set_difference算法（求两个容器的差接）
    
    </aside>
    
    ```cpp
    #include <iostream>
    using namespace std;
    #include<algorithm>//使用算法所需要包含的头文件
    #include<vector>//使用vector容器所需包含的头文件
    #include<numeric>//使用算术生成算法所需包含的头文件
    
    void Myprint(int value)//打印数据
    {
        cout << value << " ";
    }
    
    void test01()
    {
     
        vector<int>v1;
        vector<int>v2;
        for (int i = 0; i <10; i++)
        {
            v1.push_back(i);
            v2.push_back(i + 5);
        }
        //使用set_difference算法（求两个容器的差接）
        vector<int>v5;
        v5.resize(max(v1.size(), v2.size()));//给目标集合分配足够的内存空间【开辟空间最极限是取大容器】
        vector<int>::iterator itend3 = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v5.begin());//可能并集没有设想的这么大，因此用迭代器接收其并集的结束位置
        for_each(v5.begin(), itend3, Myprint);
        cout << endl;
        //反过来看V2与V1的差集
        vector<int>::iterator itend4 = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), v5.begin());//可能并集没有设想的这么大，因此用迭代器接收其并集的结束位置
        for_each(v5.begin(), itend4, Myprint);
        cout << endl;
    }
    int main()
    {
        test01();
        system("pause");
        return 0;
    }
    
    ```
    
    - set_difference算法（求两个容器的差接）
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20645.png)
        
        ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20646.png)
        
    
    ---
    
    ![Untitled](C++%E7%BC%96%E7%A8%8B%204fd88053b6e74496b4b089bee476aad8/Untitled%20647.png)
    
    ---
    

---

- 学习视频
    
    [黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1et411b73Z?vd_source=136a5c55f6da20b33c25737992286fd7)